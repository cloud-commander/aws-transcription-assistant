{"ast":null,"code":"/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nimport { ConsoleLogger as Logger } from './Logger';\nvar logger = new Logger('Hub');\nvar AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function' ? Symbol.for('amplify_default') : '@@amplify_default';\n\nfunction isLegacyCallback(callback) {\n  return callback.onHubCapsule !== undefined;\n}\n\nvar HubClass =\n/** @class */\nfunction () {\n  function HubClass(name) {\n    this.listeners = [];\n    this.patterns = [];\n    this.protectedChannels = ['core', 'auth', 'api', 'analytics', 'interactions', 'pubsub', 'storage', 'xr'];\n    this.name = name;\n  } // Note - Need to pass channel as a reference for removal to work and not anonymous function\n\n\n  HubClass.prototype.remove = function (channel, listener) {\n    if (channel instanceof RegExp) {\n      var pattern_1 = this.patterns.find(function (_a) {\n        var pattern = _a.pattern;\n        return pattern.source === channel.source;\n      });\n\n      if (!pattern_1) {\n        logger.warn(\"No listeners for \" + channel);\n        return;\n      }\n\n      this.patterns = __spread(this.patterns.filter(function (x) {\n        return x !== pattern_1;\n      }));\n    } else {\n      var holder = this.listeners[channel];\n\n      if (!holder) {\n        logger.warn(\"No listeners for \" + channel);\n        return;\n      }\n\n      this.listeners[channel] = __spread(holder.filter(function (_a) {\n        var callback = _a.callback;\n        return callback !== listener;\n      }));\n    }\n  };\n\n  HubClass.prototype.dispatch = function (channel, payload, source, ampSymbol) {\n    if (source === void 0) {\n      source = '';\n    }\n\n    if (this.protectedChannels.indexOf(channel) > -1) {\n      var hasAccess = ampSymbol === AMPLIFY_SYMBOL;\n\n      if (!hasAccess) {\n        logger.warn(\"WARNING: \" + channel + \" is protected and dispatching on it can have unintended consequences\");\n      }\n    }\n\n    var capsule = {\n      channel: channel,\n      payload: __assign({}, payload),\n      source: source,\n      patternInfo: []\n    };\n\n    try {\n      this._toListeners(capsule);\n    } catch (e) {\n      logger.error(e);\n    }\n  };\n\n  HubClass.prototype.listen = function (channel, callback, listenerName) {\n    var _this = this;\n\n    if (listenerName === void 0) {\n      listenerName = 'noname';\n    }\n\n    var cb; // Check for legacy onHubCapsule callback for backwards compatability\n\n    if (isLegacyCallback(callback)) {\n      logger.warn(\"WARNING onHubCapsule is Deprecated. Please pass in a callback.\");\n      cb = callback.onHubCapsule.bind(callback);\n    } else if (typeof callback !== 'function') {\n      throw new Error('No callback supplied to Hub');\n    } else {\n      cb = callback;\n    }\n\n    if (channel instanceof RegExp) {\n      this.patterns.push({\n        pattern: channel,\n        callback: cb\n      });\n    } else {\n      var holder = this.listeners[channel];\n\n      if (!holder) {\n        holder = [];\n        this.listeners[channel] = holder;\n      }\n\n      holder.push({\n        name: listenerName,\n        callback: cb\n      });\n    }\n\n    return function () {\n      _this.remove(channel, cb);\n    };\n  };\n\n  HubClass.prototype._toListeners = function (capsule) {\n    var channel = capsule.channel,\n        payload = capsule.payload;\n    var holder = this.listeners[channel];\n\n    if (holder) {\n      holder.forEach(function (listener) {\n        logger.debug(\"Dispatching to \" + channel + \" with \", payload);\n\n        try {\n          listener.callback(capsule);\n        } catch (e) {\n          logger.error(e);\n        }\n      });\n    }\n\n    if (this.patterns.length > 0) {\n      if (!payload.message) {\n        logger.warn(\"Cannot perform pattern matching without a message key\");\n        return;\n      }\n\n      var payloadStr_1 = payload.message;\n      this.patterns.forEach(function (pattern) {\n        var match = payloadStr_1.match(pattern.pattern);\n\n        if (match) {\n          var _a = __read(match),\n              groups = _a.slice(1);\n\n          var dispatchingCapsule = __assign(__assign({}, capsule), {\n            patternInfo: groups\n          });\n\n          try {\n            pattern.callback(dispatchingCapsule);\n          } catch (e) {\n            logger.error(e);\n          }\n        }\n      });\n    }\n  };\n\n  return HubClass;\n}();\n\nexport { HubClass };\n/*We export a __default__ instance of HubClass to use it as a\npsuedo Singleton for the main messaging bus, however you can still create\nyour own instance of HubClass() for a separate \"private bus\" of events.*/\n\nexport var Hub = new HubClass('__default__');\n/**\n * @deprecated use named import\n */\n\nexport default Hub;","map":{"version":3,"sources":["../src/Hub.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { ConsoleLogger as Logger } from './Logger';\nvar logger = new Logger('Hub');\nvar AMPLIFY_SYMBOL = (typeof Symbol !== 'undefined' &&\n    typeof Symbol.for === 'function'\n    ? Symbol.for('amplify_default')\n    : '@@amplify_default');\nfunction isLegacyCallback(callback) {\n    return callback.onHubCapsule !== undefined;\n}\nvar HubClass = /** @class */ (function () {\n    function HubClass(name) {\n        this.listeners = [];\n        this.patterns = [];\n        this.protectedChannels = [\n            'core',\n            'auth',\n            'api',\n            'analytics',\n            'interactions',\n            'pubsub',\n            'storage',\n            'xr',\n        ];\n        this.name = name;\n    }\n    // Note - Need to pass channel as a reference for removal to work and not anonymous function\n    HubClass.prototype.remove = function (channel, listener) {\n        if (channel instanceof RegExp) {\n            var pattern_1 = this.patterns.find(function (_a) {\n                var pattern = _a.pattern;\n                return pattern.source === channel.source;\n            });\n            if (!pattern_1) {\n                logger.warn(\"No listeners for \" + channel);\n                return;\n            }\n            this.patterns = __spread(this.patterns.filter(function (x) { return x !== pattern_1; }));\n        }\n        else {\n            var holder = this.listeners[channel];\n            if (!holder) {\n                logger.warn(\"No listeners for \" + channel);\n                return;\n            }\n            this.listeners[channel] = __spread(holder.filter(function (_a) {\n                var callback = _a.callback;\n                return callback !== listener;\n            }));\n        }\n    };\n    HubClass.prototype.dispatch = function (channel, payload, source, ampSymbol) {\n        if (source === void 0) { source = ''; }\n        if (this.protectedChannels.indexOf(channel) > -1) {\n            var hasAccess = ampSymbol === AMPLIFY_SYMBOL;\n            if (!hasAccess) {\n                logger.warn(\"WARNING: \" + channel + \" is protected and dispatching on it can have unintended consequences\");\n            }\n        }\n        var capsule = {\n            channel: channel,\n            payload: __assign({}, payload),\n            source: source,\n            patternInfo: [],\n        };\n        try {\n            this._toListeners(capsule);\n        }\n        catch (e) {\n            logger.error(e);\n        }\n    };\n    HubClass.prototype.listen = function (channel, callback, listenerName) {\n        var _this = this;\n        if (listenerName === void 0) { listenerName = 'noname'; }\n        var cb;\n        // Check for legacy onHubCapsule callback for backwards compatability\n        if (isLegacyCallback(callback)) {\n            logger.warn(\"WARNING onHubCapsule is Deprecated. Please pass in a callback.\");\n            cb = callback.onHubCapsule.bind(callback);\n        }\n        else if (typeof callback !== 'function') {\n            throw new Error('No callback supplied to Hub');\n        }\n        else {\n            cb = callback;\n        }\n        if (channel instanceof RegExp) {\n            this.patterns.push({\n                pattern: channel,\n                callback: cb,\n            });\n        }\n        else {\n            var holder = this.listeners[channel];\n            if (!holder) {\n                holder = [];\n                this.listeners[channel] = holder;\n            }\n            holder.push({\n                name: listenerName,\n                callback: cb,\n            });\n        }\n        return function () {\n            _this.remove(channel, cb);\n        };\n    };\n    HubClass.prototype._toListeners = function (capsule) {\n        var channel = capsule.channel, payload = capsule.payload;\n        var holder = this.listeners[channel];\n        if (holder) {\n            holder.forEach(function (listener) {\n                logger.debug(\"Dispatching to \" + channel + \" with \", payload);\n                try {\n                    listener.callback(capsule);\n                }\n                catch (e) {\n                    logger.error(e);\n                }\n            });\n        }\n        if (this.patterns.length > 0) {\n            if (!payload.message) {\n                logger.warn(\"Cannot perform pattern matching without a message key\");\n                return;\n            }\n            var payloadStr_1 = payload.message;\n            this.patterns.forEach(function (pattern) {\n                var match = payloadStr_1.match(pattern.pattern);\n                if (match) {\n                    var _a = __read(match), groups = _a.slice(1);\n                    var dispatchingCapsule = __assign(__assign({}, capsule), { patternInfo: groups });\n                    try {\n                        pattern.callback(dispatchingCapsule);\n                    }\n                    catch (e) {\n                        logger.error(e);\n                    }\n                }\n            });\n        }\n    };\n    return HubClass;\n}());\nexport { HubClass };\n/*We export a __default__ instance of HubClass to use it as a\npsuedo Singleton for the main messaging bus, however you can still create\nyour own instance of HubClass() for a separate \"private bus\" of events.*/\nexport var Hub = new HubClass('__default__');\n/**\n * @deprecated use named import\n */\nexport default Hub;\n//# sourceMappingURL=Hub.js.map"]},"metadata":{},"sourceType":"module"}