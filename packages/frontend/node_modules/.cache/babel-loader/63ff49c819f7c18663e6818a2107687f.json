{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveEndpointsConfig = exports.normalizeEndpoint = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nfunction normalizeEndpoint(endpoint, urlParser) {\n  if (typeof endpoint === \"string\") {\n    var promisified_1 = Promise.resolve(urlParser(endpoint));\n    return function () {\n      return promisified_1;\n    };\n  } else if (typeof endpoint === \"object\") {\n    var promisified_2 = Promise.resolve(endpoint);\n    return function () {\n      return promisified_2;\n    };\n  }\n\n  return endpoint;\n}\n\nexports.normalizeEndpoint = normalizeEndpoint;\n\nfunction resolveEndpointsConfig(input) {\n  var _this = this;\n\n  var tls = input.tls === undefined ? true : input.tls;\n  var endpoint = input.endpoint ? normalizeEndpoint(input.endpoint, input.urlParser) : function () {\n    return input.region().then(function (region) {\n      return tslib_1.__awaiter(_this, void 0, void 0, function () {\n        var hostname, endpoint;\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , input.regionInfoProvider(region)];\n\n            case 1:\n              hostname = (_a.sent() || {}).hostname;\n\n              if (!hostname) {\n                throw new Error(\"Cannot resolve hostname from client config\");\n              }\n\n              endpoint = input.urlParser((tls ? \"https:\" : \"http:\") + \"//\" + hostname);\n              return [2\n              /*return*/\n              , endpoint];\n          }\n        });\n      });\n    });\n  };\n  return tslib_1.__assign(tslib_1.__assign({}, input), {\n    endpoint: endpoint,\n    tls: tls\n  });\n}\n\nexports.resolveEndpointsConfig = resolveEndpointsConfig;","map":{"version":3,"sources":["../../src/EndpointsConfig.ts"],"names":[],"mappings":";;;;;;;;;AAEA,SAAgB,iBAAhB,CACE,QADF,EAEE,SAFF,EAEuB;AAErB,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,QAAM,aAAW,GAAG,OAAO,CAAC,OAAR,CAAgB,SAAU,CAAC,QAAD,CAA1B,CAApB;AACA,WAAO,YAAA;AAAM,aAAA,aAAA;AAAW,KAAxB;AACD,GAHD,MAGO,IAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AACvC,QAAM,aAAW,GAAG,OAAO,CAAC,OAAR,CAAgB,QAAhB,CAApB;AACA,WAAO,YAAA;AAAM,aAAA,aAAA;AAAW,KAAxB;AACD;;AACD,SAAO,QAAP;AACD;;AAZD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAiCA,SAAgB,sBAAhB,CACE,KADF,EACsD;AADtD,MAAA,KAAA,GAAA,IAAA;;AAGE,MAAM,GAAG,GAAG,KAAK,CAAC,GAAN,KAAc,SAAd,GAA0B,IAA1B,GAAiC,KAAK,CAAC,GAAnD;AACA,MAAM,QAAQ,GAAuB,KAAK,CAAC,QAAN,GACjC,iBAAiB,CAAC,KAAK,CAAC,QAAP,EAAiB,KAAK,CAAC,SAAvB,CADgB,GAEjC,YAAA;AACE,WAAA,KAAK,CAAC,MAAN,GAAe,IAAf,CAAoB,UAAO,MAAP,EAAa;AAAA,aAAA,OAAA,CAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;AACZ,qBAAA,CAAA;AAAA;AAAA,gBAAM,KAAK,CAAC,kBAAN,CAAyB,MAAzB,CAAN,CAAA;;;AAAb,cAAA,QAAQ,GAAG,CAAE,EAAA,CAAA,IAAA,EAAD,IAA6C,EAA9C,EAAiE,QAA5E;;AACN,kBAAI,CAAC,QAAL,EAAe;AACb,sBAAM,IAAI,KAAJ,CAAU,4CAAV,CAAN;AACD;;AACK,cAAA,QAAQ,GAAG,KAAK,CAAC,SAAN,CAAgB,CAAG,GAAG,GAAG,QAAH,GAAc,OAApB,IAA2B,IAA3B,GAAgC,QAAhD,CAAX;AACN,qBAAA,CAAA;AAAA;AAAA,gBAAO,QAAP,CAAA;;;OAN+B,CAAA;AAOhC,KAPD,CAAA;AAOE,GAVR;AAWA,SAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACK,KADL,CAAA,EACU;AACR,IAAA,QAAQ,EAAA,QADA;AAER,IAAA,GAAG,EAAA;AAFK,GADV,CAAA;AAKD;;AApBD,OAAA,CAAA,sBAAA,GAAA,sBAAA","sourcesContent":["import { Endpoint, Provider, RegionInfo,RegionInfoProvider, UrlParser } from \"@aws-sdk/types\";\n\nexport function normalizeEndpoint(\n  endpoint?: string | Endpoint | Provider<Endpoint>,\n  urlParser?: UrlParser\n): Provider<Endpoint> {\n  if (typeof endpoint === \"string\") {\n    const promisified = Promise.resolve(urlParser!(endpoint));\n    return () => promisified;\n  } else if (typeof endpoint === \"object\") {\n    const promisified = Promise.resolve(endpoint);\n    return () => promisified;\n  }\n  return endpoint!;\n}\n\nexport interface EndpointsInputConfig {\n  /**\n   * The fully qualified endpoint of the webservice. This is only required when using a custom endpoint (for example, when using a local version of S3).\n   */\n  endpoint?: string | Endpoint | Provider<Endpoint>;\n\n  /**\n   * Whether TLS is enabled for requests.\n   */\n  tls?: boolean;\n}\ninterface PreviouslyResolved {\n  regionInfoProvider: RegionInfoProvider;\n  urlParser: UrlParser;\n  region: Provider<string>;\n}\nexport interface EndpointsResolvedConfig extends Required<EndpointsInputConfig> {\n  endpoint: Provider<Endpoint>;\n}\nexport function resolveEndpointsConfig<T>(\n  input: T & EndpointsInputConfig & PreviouslyResolved\n): T & EndpointsResolvedConfig {\n  const tls = input.tls === undefined ? true : input.tls;\n  const endpoint: Provider<Endpoint> = input.endpoint\n    ? normalizeEndpoint(input.endpoint, input.urlParser)\n    : () =>\n        input.region().then(async (region) => {\n          const hostname = ((await input.regionInfoProvider(region)) || ({} as RegionInfo)).hostname;\n          if (!hostname) {\n            throw new Error(\"Cannot resolve hostname from client config\");\n          }\n          const endpoint = input.urlParser(`${tls ? \"https:\" : \"http:\"}//${hostname}`);\n          return endpoint;\n        });\n  return {\n    ...input,\n    endpoint,\n    tls,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}