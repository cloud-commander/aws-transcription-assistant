{"ast":null,"code":"/**\n * Convert BBC Kaldi json to draftJs\n * see `sample` folder for example of input and output as well as `example-usage.js`\n *\n */\nimport generateEntitiesRanges from '../generate-entities-ranges/index.js';\nimport groupWordsInParagraphsBySpeakers from './group-words-by-speakers.js';\n/**\n * groups words list from kaldi transcript based on punctuation.\n * @todo To be more accurate, should introduce an honorifics library to do the splitting of the words.\n * @param {array} words - array of words opbjects from kaldi transcript\n */\n\nconst groupWordsInParagraphs = words => {\n  const results = [];\n  let paragraph = {\n    words: [],\n    text: []\n  };\n  words.forEach(word => {\n    // if word contains punctuation\n    if (/[.?!]/.test(word.punct)) {\n      paragraph.words.push(word);\n      paragraph.text.push(word.punct);\n      paragraph.text = paragraph.text.join(' ');\n      results.push(paragraph); // reset paragraph\n\n      paragraph = {\n        words: [],\n        text: []\n      };\n    } else {\n      paragraph.words.push(word);\n      paragraph.text.push(word.punct);\n    }\n  });\n  return results;\n};\n\nconst bbcKaldiToDraft = bbcKaldiJson => {\n  const results = [];\n  let tmpWords;\n  let speakerSegmentation = null;\n  let wordsByParagraphs = []; // BBC Octo Labs API Response wraps Kaldi response around retval,\n  // while kaldi contains word attribute at root\n\n  if (bbcKaldiJson.retval !== undefined) {\n    tmpWords = bbcKaldiJson.retval.words;\n\n    if (bbcKaldiJson.retval.segmentation !== undefined) {\n      speakerSegmentation = bbcKaldiJson.retval.segmentation;\n    }\n  } else {\n    tmpWords = bbcKaldiJson.words;\n\n    if (bbcKaldiJson.segmentation !== undefined) {\n      speakerSegmentation = bbcKaldiJson.segmentation;\n    }\n  }\n\n  if (speakerSegmentation === null) {\n    wordsByParagraphs = groupWordsInParagraphs(tmpWords);\n  } else {\n    wordsByParagraphs = groupWordsInParagraphsBySpeakers(tmpWords, speakerSegmentation);\n  }\n\n  wordsByParagraphs.forEach((paragraph, i) => {\n    // if paragraph contain words\n    // eg sometimes the speaker segmentation might not contain words :man-shrugging:\n    if (paragraph.words[0] !== undefined) {\n      let speakerLabel = `TBC ${i}`;\n\n      if (speakerSegmentation !== null) {\n        speakerLabel = paragraph.speaker;\n      }\n\n      const draftJsContentBlockParagraph = {\n        text: paragraph.text,\n        type: 'paragraph',\n        data: {\n          speaker: speakerLabel,\n          words: paragraph.words,\n          start: paragraph.words[0].start\n        },\n        // the entities as ranges are each word in the space-joined text,\n        // so it needs to be compute for each the offset from the beginning of the paragraph and the length\n        entityRanges: generateEntitiesRanges(paragraph.words, 'punct') // wordAttributeName\n\n      };\n      results.push(draftJsContentBlockParagraph);\n    }\n  });\n  return results;\n};\n\nexport default bbcKaldiToDraft;","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/packages/frontend/src/packages/stt-adapters/bbc-kaldi/index.js"],"names":["generateEntitiesRanges","groupWordsInParagraphsBySpeakers","groupWordsInParagraphs","words","results","paragraph","text","forEach","word","test","punct","push","join","bbcKaldiToDraft","bbcKaldiJson","tmpWords","speakerSegmentation","wordsByParagraphs","retval","undefined","segmentation","i","speakerLabel","speaker","draftJsContentBlockParagraph","type","data","start","entityRanges"],"mappings":"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","sourcesContent":["/**\n * Convert BBC Kaldi json to draftJs\n * see `sample` folder for example of input and output as well as `example-usage.js`\n *\n */\n\nimport generateEntitiesRanges from '../generate-entities-ranges/index.js';\nimport groupWordsInParagraphsBySpeakers from './group-words-by-speakers.js';\n/**\n * groups words list from kaldi transcript based on punctuation.\n * @todo To be more accurate, should introduce an honorifics library to do the splitting of the words.\n * @param {array} words - array of words opbjects from kaldi transcript\n */\n\nconst groupWordsInParagraphs = words => {\n  const results = [];\n  let paragraph = { words: [], text: [] };\n\n  words.forEach(word => {\n    // if word contains punctuation\n    if (/[.?!]/.test(word.punct)) {\n      paragraph.words.push(word);\n      paragraph.text.push(word.punct);\n      paragraph.text = paragraph.text.join(' ');\n      results.push(paragraph);\n      // reset paragraph\n      paragraph = { words: [], text: [] };\n    } else {\n      paragraph.words.push(word);\n      paragraph.text.push(word.punct);\n    }\n  });\n\n  return results;\n};\n\nconst bbcKaldiToDraft = bbcKaldiJson => {\n  const results = [];\n  let tmpWords;\n  let speakerSegmentation = null;\n  let wordsByParagraphs = [];\n\n  // BBC Octo Labs API Response wraps Kaldi response around retval,\n  // while kaldi contains word attribute at root\n  if (bbcKaldiJson.retval !== undefined) {\n    tmpWords = bbcKaldiJson.retval.words;\n    if (bbcKaldiJson.retval.segmentation !== undefined) {\n      speakerSegmentation = bbcKaldiJson.retval.segmentation;\n    }\n  } else {\n    tmpWords = bbcKaldiJson.words;\n    if (bbcKaldiJson.segmentation !== undefined) {\n      speakerSegmentation = bbcKaldiJson.segmentation;\n    }\n  }\n\n  if (speakerSegmentation === null) {\n    wordsByParagraphs = groupWordsInParagraphs(tmpWords);\n  } else {\n    wordsByParagraphs = groupWordsInParagraphsBySpeakers(tmpWords, speakerSegmentation);\n  }\n\n  wordsByParagraphs.forEach((paragraph, i) => {\n    // if paragraph contain words\n    // eg sometimes the speaker segmentation might not contain words :man-shrugging:\n    if (paragraph.words[0] !== undefined) {\n      let speakerLabel = `TBC ${ i }`;\n      if (speakerSegmentation !== null) {\n        speakerLabel = paragraph.speaker;\n      }\n\n      const draftJsContentBlockParagraph = {\n        text: paragraph.text,\n        type: 'paragraph',\n        data: {\n          speaker: speakerLabel,\n          words: paragraph.words,\n          start: paragraph.words[0].start\n        },\n        // the entities as ranges are each word in the space-joined text,\n        // so it needs to be compute for each the offset from the beginning of the paragraph and the length\n        entityRanges: generateEntitiesRanges(paragraph.words, 'punct') // wordAttributeName\n      };\n      results.push(draftJsContentBlockParagraph);\n    }\n  });\n\n  return results;\n};\n\nexport default bbcKaldiToDraft;\n"]},"metadata":{},"sourceType":"module"}