{"ast":null,"code":"'use strict';\n/**\n * Makes argument to be an array if it's not\n *\n * @param input\n * @returns {Array}\n */\n\nmodule.exports.makeItArrayIfItsNot = function (input) {\n  return Object.prototype.toString.call(input) !== '[object Array]' ? [input] : input;\n};\n/**\n *\n * Utilizes bisection method to search an interval to which\n * point belongs to, then returns an index of left border\n * of the interval\n *\n * @param {Number} point\n * @param {Array} intervals\n * @returns {Number}\n */\n\n\nmodule.exports.findIntervalLeftBorderIndex = function (point, intervals) {\n  //If point is beyond given intervals\n  if (point < intervals[0]) return 0;\n  if (point > intervals[intervals.length - 1]) return intervals.length - 1; //If point is inside interval\n  //Start searching on a full range of intervals\n\n  var indexOfNumberToCompare,\n      leftBorderIndex = 0,\n      rightBorderIndex = intervals.length - 1; //Reduce searching range till it find an interval point belongs to using binary search\n\n  while (rightBorderIndex - leftBorderIndex !== 1) {\n    indexOfNumberToCompare = leftBorderIndex + Math.floor((rightBorderIndex - leftBorderIndex) / 2);\n    point >= intervals[indexOfNumberToCompare] ? leftBorderIndex = indexOfNumberToCompare : rightBorderIndex = indexOfNumberToCompare;\n  }\n\n  return leftBorderIndex;\n};","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/node_modules/everpolate/lib/help.js"],"names":["module","exports","makeItArrayIfItsNot","input","Object","prototype","toString","call","findIntervalLeftBorderIndex","point","intervals","length","indexOfNumberToCompare","leftBorderIndex","rightBorderIndex","Math","floor"],"mappings":"AAAA;AAEA;;;;;;;AAOAA,MAAM,CAACC,OAAP,CAAeC,mBAAf,GAAqC,UAAUC,KAAV,EAAiB;AACpD,SAAOC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAAgCJ,KAAhC,MAA4C,gBAA5C,GACH,CAACA,KAAD,CADG,GAEHA,KAFJ;AAGD,CAJD;AAMA;;;;;;;;;;;;AAWAH,MAAM,CAACC,OAAP,CAAeO,2BAAf,GAA6C,UAAUC,KAAV,EAAiBC,SAAjB,EAA4B;AACvE;AACA,MAAID,KAAK,GAAGC,SAAS,CAAC,CAAD,CAArB,EACE,OAAO,CAAP;AACF,MAAID,KAAK,GAAGC,SAAS,CAACA,SAAS,CAACC,MAAV,GAAmB,CAApB,CAArB,EACE,OAAOD,SAAS,CAACC,MAAV,GAAmB,CAA1B,CALqE,CAMvE;AACA;;AACA,MAAIC,sBAAJ;AAAA,MACIC,eAAe,GAAG,CADtB;AAAA,MAEIC,gBAAgB,GAAGJ,SAAS,CAACC,MAAV,GAAmB,CAF1C,CARuE,CAWvE;;AACA,SAAOG,gBAAgB,GAAGD,eAAnB,KAAuC,CAA9C,EAAiD;AAC/CD,IAAAA,sBAAsB,GAAGC,eAAe,GAAGE,IAAI,CAACC,KAAL,CAAW,CAACF,gBAAgB,GAAGD,eAApB,IAAqC,CAAhD,CAA3C;AACAJ,IAAAA,KAAK,IAAIC,SAAS,CAACE,sBAAD,CAAlB,GACIC,eAAe,GAAGD,sBADtB,GAEIE,gBAAgB,GAAGF,sBAFvB;AAGD;;AACD,SAAOC,eAAP;AACD,CAnBD","sourcesContent":["'use strict';\n\n/**\n * Makes argument to be an array if it's not\n *\n * @param input\n * @returns {Array}\n */\n\nmodule.exports.makeItArrayIfItsNot = function (input) {\n  return Object.prototype.toString.call( input ) !== '[object Array]'\n    ? [input]\n    : input\n}\n\n/**\n *\n * Utilizes bisection method to search an interval to which\n * point belongs to, then returns an index of left border\n * of the interval\n *\n * @param {Number} point\n * @param {Array} intervals\n * @returns {Number}\n */\n\nmodule.exports.findIntervalLeftBorderIndex = function (point, intervals) {\n  //If point is beyond given intervals\n  if (point < intervals[0])\n    return 0\n  if (point > intervals[intervals.length - 1])\n    return intervals.length - 1\n  //If point is inside interval\n  //Start searching on a full range of intervals\n  var indexOfNumberToCompare \n    , leftBorderIndex = 0\n    , rightBorderIndex = intervals.length - 1\n  //Reduce searching range till it find an interval point belongs to using binary search\n  while (rightBorderIndex - leftBorderIndex !== 1) {\n    indexOfNumberToCompare = leftBorderIndex + Math.floor((rightBorderIndex - leftBorderIndex)/2)\n    point >= intervals[indexOfNumberToCompare]\n      ? leftBorderIndex = indexOfNumberToCompare\n      : rightBorderIndex = indexOfNumberToCompare\n  }\n  return leftBorderIndex\n}"]},"metadata":{},"sourceType":"script"}