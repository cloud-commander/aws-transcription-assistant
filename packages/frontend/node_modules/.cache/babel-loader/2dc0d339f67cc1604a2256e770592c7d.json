{"ast":null,"code":"/* eslint-disable */\n\n/**\n edge cases\n- more segments then words - not an issue if you start by matching words with segment\nand handle edge case where it doesn't find a match\n- more words then segments - orphan words?\n*\n* Takes in list of words and list of paragraphs (paragraphs have speakers info associated with it)\n```js\n{\n  \"words\": [\n    {\n      \"id\": 0,\n      \"start\": 13.02,\n      \"end\": 13.17,\n      \"text\": \"There\"\n    },\n    {\n      \"id\": 1,\n      \"start\": 13.17,\n      \"end\": 13.38,\n      \"text\": \"is\"\n    },\n    ...\n    ],\n  \"paragraphs\": [\n    {\n      \"id\": 0,\n      \"start\": 13.02,\n      \"end\": 13.86,\n      \"speaker\": \"TBC 00\"\n    },\n    {\n      \"id\": 1,\n      \"start\": 13.86,\n      \"end\": 19.58,\n      \"speaker\": \"TBC 1\"\n    },\n    ...\n  ]\n}\n```\n*  and returns a list of words grouped into paragraphs, with words, text and speaker attribute\n```js\n[\n  {\n    \"words\": [\n      {\n        \"id\": 0,\n        \"start\": 13.02,\n        \"end\": 13.17,\n        \"text\": \"There\"\n      },\n      {\n        \"id\": 1,\n        \"start\": 13.17,\n        \"end\": 13.38,\n        \"text\": \"is\"\n      },\n      {\n        \"id\": 2,\n        \"start\": 13.38,\n        \"end\": 13.44,\n        \"text\": \"a\"\n      },\n      {\n        \"id\": 3,\n        \"start\": 13.44,\n        \"end\": 13.86,\n        \"text\": \"day.\"\n      }\n    ],\n    \"text\": \"There is a day.\",\n    \"speaker\": \"TBC 00\"\n  },\n  ...\n]\n```\n */\nfunction groupWordsInParagraphsBySpeakers(words, segments) {\n  const result = addWordsToSpeakersParagraphs(words, segments);\n  return result;\n}\n\n;\n\nfunction addWordsToSpeakersParagraphs(words, segments) {\n  const results = [];\n  let currentSegment = 'UKN';\n  let currentSegmentIndex = 0;\n  let previousSegmentIndex = 0;\n  let paragraph = {\n    words: [],\n    text: '',\n    speaker: ''\n  };\n  words.forEach(word => {\n    currentSegment = findSegmentForWord(word, segments); // if a segment exists for the word\n\n    if (currentSegment) {\n      currentSegmentIndex = segments.indexOf(currentSegment);\n\n      if (currentSegmentIndex === previousSegmentIndex) {\n        paragraph.words.push(word);\n        paragraph.text += word.text + ' ';\n        paragraph.speaker = currentSegment.speaker;\n      } else {\n        previousSegmentIndex = currentSegmentIndex;\n        paragraph.text.trim();\n        results.push(paragraph);\n        paragraph = {\n          words: [],\n          text: '',\n          speaker: ''\n        };\n        paragraph.words.push(word);\n        paragraph.text += word.text + ' ';\n        paragraph.speaker = currentSegment.speaker;\n      }\n    }\n  });\n  results.push(paragraph);\n  return results;\n}\n/**\n* Helper functions\n*/\n\n/**\n* given word start and end time attributes\n* looks for segment range that contains that word\n* if it doesn't find any it returns a segment with `UKN`\n* speaker attributes.\n* @param {object} word - word object\n* @param {array} segments - list of segments objects\n* @return {object} - a single segment whose range contains the word\n*/\n\n\nfunction findSegmentForWord(word, segments) {\n  const tmpSegment = segments.find(seg => {\n    if (word.start >= seg.start && word.end <= seg.end) {\n      return seg;\n    }\n  });\n  return tmpSegment;\n}\n\nexport default groupWordsInParagraphsBySpeakers;","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/packages/frontend/src/packages/stt-adapters/digital-paper-edit/group-words-by-speakers.js"],"names":["groupWordsInParagraphsBySpeakers","words","segments","result","addWordsToSpeakersParagraphs","results","currentSegment","currentSegmentIndex","previousSegmentIndex","paragraph","text","speaker","forEach","word","findSegmentForWord","indexOf","push","trim","tmpSegment","find","seg","start","end"],"mappings":"AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8EA,SAASA,gCAAT,CAA0CC,KAA1C,EAAiDC,QAAjD,EAA2D;AACzD,QAAMC,MAAM,GAAGC,4BAA4B,CAACH,KAAD,EAAQC,QAAR,CAA3C;AAEA,SAAOC,MAAP;AACD;;AAAA;;AAED,SAASC,4BAAT,CAAuCH,KAAvC,EAA8CC,QAA9C,EAAwD;AACtD,QAAMG,OAAO,GAAG,EAAhB;AACA,MAAIC,cAAc,GAAG,KAArB;AACA,MAAIC,mBAAmB,GAAG,CAA1B;AACA,MAAIC,oBAAoB,GAAG,CAA3B;AACA,MAAIC,SAAS,GAAG;AAAER,IAAAA,KAAK,EAAE,EAAT;AAAaS,IAAAA,IAAI,EAAE,EAAnB;AAAuBC,IAAAA,OAAO,EAAE;AAAhC,GAAhB;AACAV,EAAAA,KAAK,CAACW,OAAN,CAAeC,IAAD,IAAU;AACtBP,IAAAA,cAAc,GAAGQ,kBAAkB,CAACD,IAAD,EAAOX,QAAP,CAAnC,CADsB,CAEtB;;AACA,QAAII,cAAJ,EAAoB;AAClBC,MAAAA,mBAAmB,GAAGL,QAAQ,CAACa,OAAT,CAAiBT,cAAjB,CAAtB;;AACA,UAAIC,mBAAmB,KAAKC,oBAA5B,EAAkD;AAChDC,QAAAA,SAAS,CAACR,KAAV,CAAgBe,IAAhB,CAAqBH,IAArB;AACAJ,QAAAA,SAAS,CAACC,IAAV,IAAkBG,IAAI,CAACH,IAAL,GAAY,GAA9B;AACAD,QAAAA,SAAS,CAACE,OAAV,GAAoBL,cAAc,CAACK,OAAnC;AACD,OAJD,MAKK;AACHH,QAAAA,oBAAoB,GAAGD,mBAAvB;AACAE,QAAAA,SAAS,CAACC,IAAV,CAAeO,IAAf;AACAZ,QAAAA,OAAO,CAACW,IAAR,CAAaP,SAAb;AACAA,QAAAA,SAAS,GAAG;AAAER,UAAAA,KAAK,EAAE,EAAT;AAAaS,UAAAA,IAAI,EAAE,EAAnB;AAAuBC,UAAAA,OAAO,EAAE;AAAhC,SAAZ;AACAF,QAAAA,SAAS,CAACR,KAAV,CAAgBe,IAAhB,CAAqBH,IAArB;AACAJ,QAAAA,SAAS,CAACC,IAAV,IAAkBG,IAAI,CAACH,IAAL,GAAY,GAA9B;AACAD,QAAAA,SAAS,CAACE,OAAV,GAAoBL,cAAc,CAACK,OAAnC;AACD;AACF;AACF,GApBD;AAqBAN,EAAAA,OAAO,CAACW,IAAR,CAAaP,SAAb;AAEA,SAAOJ,OAAP;AACD;AAED;;;;AAIA;;;;;;;;;;;AASA,SAASS,kBAAT,CAA4BD,IAA5B,EAAkCX,QAAlC,EAA4C;AAE1C,QAAMgB,UAAU,GAAGhB,QAAQ,CAACiB,IAAT,CAAeC,GAAD,IAAS;AACxC,QAAKP,IAAI,CAACQ,KAAL,IAAcD,GAAG,CAACC,KAAnB,IAA8BR,IAAI,CAACS,GAAL,IAAYF,GAAG,CAACE,GAAlD,EAAwD;AACtD,aAAOF,GAAP;AACD;AACF,GAJkB,CAAnB;AAMA,SAAOF,UAAP;AACD;;AAED,eAAelB,gCAAf","sourcesContent":["/* eslint-disable */\n/**\n edge cases\n- more segments then words - not an issue if you start by matching words with segment\nand handle edge case where it doesn't find a match\n- more words then segments - orphan words?\n*\n* Takes in list of words and list of paragraphs (paragraphs have speakers info associated with it)\n```js\n{\n  \"words\": [\n    {\n      \"id\": 0,\n      \"start\": 13.02,\n      \"end\": 13.17,\n      \"text\": \"There\"\n    },\n    {\n      \"id\": 1,\n      \"start\": 13.17,\n      \"end\": 13.38,\n      \"text\": \"is\"\n    },\n    ...\n    ],\n  \"paragraphs\": [\n    {\n      \"id\": 0,\n      \"start\": 13.02,\n      \"end\": 13.86,\n      \"speaker\": \"TBC 00\"\n    },\n    {\n      \"id\": 1,\n      \"start\": 13.86,\n      \"end\": 19.58,\n      \"speaker\": \"TBC 1\"\n    },\n    ...\n  ]\n}\n```\n*  and returns a list of words grouped into paragraphs, with words, text and speaker attribute\n```js\n[\n  {\n    \"words\": [\n      {\n        \"id\": 0,\n        \"start\": 13.02,\n        \"end\": 13.17,\n        \"text\": \"There\"\n      },\n      {\n        \"id\": 1,\n        \"start\": 13.17,\n        \"end\": 13.38,\n        \"text\": \"is\"\n      },\n      {\n        \"id\": 2,\n        \"start\": 13.38,\n        \"end\": 13.44,\n        \"text\": \"a\"\n      },\n      {\n        \"id\": 3,\n        \"start\": 13.44,\n        \"end\": 13.86,\n        \"text\": \"day.\"\n      }\n    ],\n    \"text\": \"There is a day.\",\n    \"speaker\": \"TBC 00\"\n  },\n  ...\n]\n```\n */\nfunction groupWordsInParagraphsBySpeakers(words, segments) {\n  const result = addWordsToSpeakersParagraphs(words, segments);\n\n  return result;\n};\n\nfunction addWordsToSpeakersParagraphs (words, segments) {\n  const results = [];\n  let currentSegment = 'UKN';\n  let currentSegmentIndex = 0;\n  let previousSegmentIndex = 0;\n  let paragraph = { words: [], text: '', speaker: '' };\n  words.forEach((word) => {\n    currentSegment = findSegmentForWord(word, segments);\n    // if a segment exists for the word\n    if (currentSegment) {\n      currentSegmentIndex = segments.indexOf(currentSegment);\n      if (currentSegmentIndex === previousSegmentIndex) {\n        paragraph.words.push(word);\n        paragraph.text += word.text + ' ';\n        paragraph.speaker = currentSegment.speaker;\n      }\n      else {\n        previousSegmentIndex = currentSegmentIndex;\n        paragraph.text.trim();\n        results.push(paragraph);\n        paragraph = { words: [], text: '', speaker: '' };\n        paragraph.words.push(word);\n        paragraph.text += word.text + ' ';\n        paragraph.speaker = currentSegment.speaker;\n      }\n    }\n  });\n  results.push(paragraph);\n\n  return results;\n}\n\n/**\n* Helper functions\n*/\n\n/**\n* given word start and end time attributes\n* looks for segment range that contains that word\n* if it doesn't find any it returns a segment with `UKN`\n* speaker attributes.\n* @param {object} word - word object\n* @param {array} segments - list of segments objects\n* @return {object} - a single segment whose range contains the word\n*/\nfunction findSegmentForWord(word, segments) {\n\n  const tmpSegment = segments.find((seg) => {\n    if ((word.start >= seg.start) && (word.end <= seg.end)) {\n      return seg;\n    }\n  });\n\n  return tmpSegment;\n}\n\nexport default groupWordsInParagraphsBySpeakers;\n"]},"metadata":{},"sourceType":"module"}