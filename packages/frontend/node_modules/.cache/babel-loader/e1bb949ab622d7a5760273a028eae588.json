{"ast":null,"code":"\"use strict\";\n/**\n * Lazy String holder for JSON typed contents.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LazyJsonString = exports.StringWrapper = void 0;\n\nvar tslib_1 = require(\"tslib\");\n/**\n * Because of https://github.com/microsoft/tslib/issues/95,\n * TS 'extends' shim doesn't support extending native types like String.\n * So here we create StringWrapper that duplicate everything from String\n * class including its prototype chain. So we can extend from here.\n */\n// @ts-ignore StringWrapper implementation is not a simple constructor\n\n\nexports.StringWrapper = function () {\n  //@ts-ignore 'this' cannot be assigned to any, but Object.getPrototypeOf accepts any\n  var Class = Object.getPrototypeOf(this).constructor;\n  var Constructor = Function.bind.apply(String, tslib_1.__spread([null], arguments)); //@ts-ignore Call wrapped String constructor directly, don't bother typing it.\n\n  var instance = new Constructor();\n  Object.setPrototypeOf(instance, Class.prototype);\n  return instance;\n};\n\nexports.StringWrapper.prototype = Object.create(String.prototype, {\n  constructor: {\n    value: exports.StringWrapper,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(exports.StringWrapper, String);\n\nvar LazyJsonString =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(LazyJsonString, _super);\n\n  function LazyJsonString() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LazyJsonString.prototype.deserializeJSON = function () {\n    return JSON.parse(_super.prototype.toString.call(this));\n  };\n\n  LazyJsonString.prototype.toJSON = function () {\n    return _super.prototype.toString.call(this);\n  };\n\n  LazyJsonString.fromObject = function (object) {\n    if (object instanceof LazyJsonString) {\n      return object;\n    } else if (object instanceof String || typeof object === \"string\") {\n      return new LazyJsonString(object);\n    }\n\n    return new LazyJsonString(JSON.stringify(object));\n  };\n\n  return LazyJsonString;\n}(exports.StringWrapper);\n\nexports.LazyJsonString = LazyJsonString;","map":{"version":3,"sources":["../../src/lazy-json.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;AAQA;;;;;;AAMA;;;AACa,OAAA,CAAA,aAAA,GAA+B,YAAA;AAC1C;AACA,MAAM,KAAK,GAAG,MAAM,CAAC,cAAP,CAAsB,IAAtB,EAA4B,WAA1C;AACA,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAT,CAAc,KAAd,CAAoB,MAApB,EAA0B,OAAA,CAAA,QAAA,CAAA,CAAG,IAAH,CAAA,EAAmB,SAAnB,CAA1B,CAApB,CAH0C,CAI1C;;AACA,MAAM,QAAQ,GAAG,IAAI,WAAJ,EAAjB;AACA,EAAA,MAAM,CAAC,cAAP,CAAsB,QAAtB,EAAgC,KAAK,CAAC,SAAtC;AACA,SAAO,QAAP;AACD,CARY;;AASb,OAAA,CAAA,aAAA,CAAc,SAAd,GAA0B,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,SAArB,EAAgC;AACxD,EAAA,WAAW,EAAE;AACX,IAAA,KAAK,EAAE,OAAA,CAAA,aADI;AAEX,IAAA,UAAU,EAAE,KAFD;AAGX,IAAA,QAAQ,EAAE,IAHC;AAIX,IAAA,YAAY,EAAE;AAJH;AAD2C,CAAhC,CAA1B;AAQA,MAAM,CAAC,cAAP,CAAsB,OAAA,CAAA,aAAtB,EAAqC,MAArC;;AAEA,IAAA,cAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAoC,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,EAAA,MAAA;;AAApC,WAAA,cAAA,GAAA;;AAiBC;;AAhBC,EAAA,cAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,WAAO,IAAI,CAAC,KAAL,CAAW,MAAA,CAAA,SAAA,CAAM,QAAN,CAAc,IAAd,CAAc,IAAd,CAAX,CAAP;AACD,GAFD;;AAIA,EAAA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACE,WAAO,MAAA,CAAA,SAAA,CAAM,QAAN,CAAc,IAAd,CAAc,IAAd,CAAP;AACD,GAFD;;AAIO,EAAA,cAAA,CAAA,UAAA,GAAP,UAAkB,MAAlB,EAA6B;AAC3B,QAAI,MAAM,YAAY,cAAtB,EAAsC;AACpC,aAAO,MAAP;AACD,KAFD,MAEO,IAAI,MAAM,YAAY,MAAlB,IAA4B,OAAO,MAAP,KAAkB,QAAlD,EAA4D;AACjE,aAAO,IAAI,cAAJ,CAAmB,MAAnB,CAAP;AACD;;AACD,WAAO,IAAI,cAAJ,CAAmB,IAAI,CAAC,SAAL,CAAe,MAAf,CAAnB,CAAP;AACD,GAPM;;AAQT,SAAA,cAAA;AAAC,CAjBD,CAAoC,OAAA,CAAA,aAApC,CAAA;;AAAa,OAAA,CAAA,cAAA,GAAA,cAAA","sourcesContent":["/**\n * Lazy String holder for JSON typed contents.\n */\n\ninterface StringWrapper {\n  new (arg: any): String;\n}\n\n/**\n * Because of https://github.com/microsoft/tslib/issues/95,\n * TS 'extends' shim doesn't support extending native types like String.\n * So here we create StringWrapper that duplicate everything from String\n * class including its prototype chain. So we can extend from here.\n */\n// @ts-ignore StringWrapper implementation is not a simple constructor\nexport const StringWrapper: StringWrapper = function () {\n  //@ts-ignore 'this' cannot be assigned to any, but Object.getPrototypeOf accepts any\n  const Class = Object.getPrototypeOf(this).constructor;\n  const Constructor = Function.bind.apply(String, [null as any, ...arguments]);\n  //@ts-ignore Call wrapped String constructor directly, don't bother typing it.\n  const instance = new Constructor();\n  Object.setPrototypeOf(instance, Class.prototype);\n  return instance as String;\n};\nStringWrapper.prototype = Object.create(String.prototype, {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  },\n});\nObject.setPrototypeOf(StringWrapper, String);\n\nexport class LazyJsonString extends StringWrapper {\n  deserializeJSON(): any {\n    return JSON.parse(super.toString());\n  }\n\n  toJSON(): string {\n    return super.toString();\n  }\n\n  static fromObject(object: any): LazyJsonString {\n    if (object instanceof LazyJsonString) {\n      return object;\n    } else if (object instanceof String || typeof object === \"string\") {\n      return new LazyJsonString(object);\n    }\n    return new LazyJsonString(JSON.stringify(object));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}