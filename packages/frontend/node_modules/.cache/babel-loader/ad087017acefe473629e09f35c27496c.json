{"ast":null,"code":"export const groupWordsBySpeakerLabel = words => {\n  const groupedWords = [];\n  let currentSpeaker = '';\n  words.forEach(word => {\n    if (word.speaker_label === currentSpeaker) {\n      groupedWords[groupedWords.length - 1].words.push(word);\n    } else {\n      currentSpeaker = word.speaker_label; // start new speaker block\n\n      groupedWords.push({\n        speaker: word.speaker_label,\n        words: [word]\n      });\n    }\n  });\n  return groupedWords;\n};\nexport const findSpeakerForWord = (word, segments) => {\n  const startTime = parseFloat(word.start_time);\n  const endTime = parseFloat(word.end_time);\n  const firstMatchingSegment = segments.find(seg => {\n    return startTime >= parseFloat(seg.start_time) && endTime <= parseFloat(seg.end_time);\n  });\n\n  if (firstMatchingSegment === undefined) {\n    return 'UKN';\n  } else {\n    return firstMatchingSegment.speaker_label.replace('spk_', '');\n  }\n};\n\nconst addSpeakerLabelToWords = (words, segments) => {\n  return words.map(w => Object.assign(w, {\n    'speaker_label': findSpeakerForWord(w, segments)\n  }));\n};\n\nexport const groupWordsBySpeaker = (words, speakerLabels) => {\n  const wordsWithSpeakers = addSpeakerLabelToWords(words, speakerLabels.segments);\n  return groupWordsBySpeakerLabel(wordsWithSpeakers);\n};","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/packages/frontend/src/packages/stt-adapters/amazon-transcribe/group-words-by-speakers.js"],"names":["groupWordsBySpeakerLabel","words","groupedWords","currentSpeaker","forEach","word","speaker_label","length","push","speaker","findSpeakerForWord","segments","startTime","parseFloat","start_time","endTime","end_time","firstMatchingSegment","find","seg","undefined","replace","addSpeakerLabelToWords","map","w","Object","assign","groupWordsBySpeaker","speakerLabels","wordsWithSpeakers"],"mappings":"AAAA,OAAO,MAAMA,wBAAwB,GAAIC,KAAD,IAAW;AACjD,QAAMC,YAAY,GAAG,EAArB;AACA,MAAIC,cAAc,GAAG,EAArB;AACAF,EAAAA,KAAK,CAACG,OAAN,CAAeC,IAAD,IAAU;AACtB,QAAIA,IAAI,CAACC,aAAL,KAAuBH,cAA3B,EAA2C;AACzCD,MAAAA,YAAY,CAACA,YAAY,CAACK,MAAb,GAAsB,CAAvB,CAAZ,CAAsCN,KAAtC,CAA4CO,IAA5C,CAAiDH,IAAjD;AACD,KAFD,MAEO;AACLF,MAAAA,cAAc,GAAGE,IAAI,CAACC,aAAtB,CADK,CAEL;;AACAJ,MAAAA,YAAY,CAACM,IAAb,CAAkB;AAChBC,QAAAA,OAAO,EAAEJ,IAAI,CAACC,aADE;AAEhBL,QAAAA,KAAK,EAAE,CAAEI,IAAF;AAFS,OAAlB;AAGD;AACF,GAVD;AAYA,SAAOH,YAAP;AACD,CAhBM;AAkBP,OAAO,MAAMQ,kBAAkB,GAAG,CAACL,IAAD,EAAOM,QAAP,KAAoB;AACpD,QAAMC,SAAS,GAAGC,UAAU,CAACR,IAAI,CAACS,UAAN,CAA5B;AACA,QAAMC,OAAO,GAAGF,UAAU,CAACR,IAAI,CAACW,QAAN,CAA1B;AACA,QAAMC,oBAAoB,GAAGN,QAAQ,CAACO,IAAT,CAAeC,GAAD,IAAS;AAClD,WAAOP,SAAS,IAAIC,UAAU,CAACM,GAAG,CAACL,UAAL,CAAvB,IAA2CC,OAAO,IAAIF,UAAU,CAACM,GAAG,CAACH,QAAL,CAAvE;AACD,GAF4B,CAA7B;;AAGA,MAAIC,oBAAoB,KAAKG,SAA7B,EAAwC;AACtC,WAAO,KAAP;AACD,GAFD,MAEO;AACL,WAAOH,oBAAoB,CAACX,aAArB,CAAmCe,OAAnC,CAA2C,MAA3C,EAAmD,EAAnD,CAAP;AACD;AACF,CAXM;;AAaP,MAAMC,sBAAsB,GAAG,CAACrB,KAAD,EAAQU,QAAR,KAAqB;AAClD,SAAOV,KAAK,CAACsB,GAAN,CAAUC,CAAC,IAAIC,MAAM,CAACC,MAAP,CAAcF,CAAd,EAAiB;AAAE,qBAAiBd,kBAAkB,CAACc,CAAD,EAAIb,QAAJ;AAArC,GAAjB,CAAf,CAAP;AACD,CAFD;;AAIA,OAAO,MAAMgB,mBAAmB,GAAG,CAAC1B,KAAD,EAAQ2B,aAAR,KAA0B;AAC3D,QAAMC,iBAAiB,GAAGP,sBAAsB,CAACrB,KAAD,EAAQ2B,aAAa,CAACjB,QAAtB,CAAhD;AAEA,SAAOX,wBAAwB,CAAC6B,iBAAD,CAA/B;AACD,CAJM","sourcesContent":["export const groupWordsBySpeakerLabel = (words) => {\n  const groupedWords = [];\n  let currentSpeaker = '';\n  words.forEach((word) => {\n    if (word.speaker_label === currentSpeaker) {\n      groupedWords[groupedWords.length - 1].words.push(word);\n    } else {\n      currentSpeaker = word.speaker_label;\n      // start new speaker block\n      groupedWords.push({\n        speaker: word.speaker_label,\n        words: [ word ] });\n    }\n  });\n\n  return groupedWords;\n};\n\nexport const findSpeakerForWord = (word, segments) => {\n  const startTime = parseFloat(word.start_time);\n  const endTime = parseFloat(word.end_time);\n  const firstMatchingSegment = segments.find((seg) => {\n    return startTime >= parseFloat(seg.start_time) && endTime <= parseFloat(seg.end_time);\n  });\n  if (firstMatchingSegment === undefined) {\n    return 'UKN';\n  } else {\n    return firstMatchingSegment.speaker_label.replace('spk_', '');\n  }\n};\n\nconst addSpeakerLabelToWords = (words, segments) => {\n  return words.map(w => Object.assign(w, { 'speaker_label': findSpeakerForWord(w, segments) }));\n};\n\nexport const groupWordsBySpeaker = (words, speakerLabels) => {\n  const wordsWithSpeakers = addSpeakerLabelToWords(words, speakerLabels.segments);\n\n  return groupWordsBySpeakerLabel(wordsWithSpeakers);\n};"]},"metadata":{},"sourceType":"module"}