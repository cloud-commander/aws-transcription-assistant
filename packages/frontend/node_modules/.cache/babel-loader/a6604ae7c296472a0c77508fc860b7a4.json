{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HeaderMarshaller = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\n\nvar Int64_1 = require(\"./Int64\");\n/**\n * @internal\n */\n\n\nvar HeaderMarshaller =\n/** @class */\nfunction () {\n  function HeaderMarshaller(toUtf8, fromUtf8) {\n    this.toUtf8 = toUtf8;\n    this.fromUtf8 = fromUtf8;\n  }\n\n  HeaderMarshaller.prototype.format = function (headers) {\n    var e_1, _a, e_2, _b;\n\n    var chunks = [];\n\n    try {\n      for (var _c = tslib_1.__values(Object.keys(headers)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var headerName = _d.value;\n        var bytes = this.fromUtf8(headerName);\n        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var out = new Uint8Array(chunks.reduce(function (carry, bytes) {\n      return carry + bytes.byteLength;\n    }, 0));\n    var position = 0;\n\n    try {\n      for (var chunks_1 = tslib_1.__values(chunks), chunks_1_1 = chunks_1.next(); !chunks_1_1.done; chunks_1_1 = chunks_1.next()) {\n        var chunk = chunks_1_1.value;\n        out.set(chunk, position);\n        position += chunk.byteLength;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (chunks_1_1 && !chunks_1_1.done && (_b = chunks_1.return)) _b.call(chunks_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return out;\n  };\n\n  HeaderMarshaller.prototype.formatHeaderValue = function (header) {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? 0\n        /* boolTrue */\n        : 1\n        /* boolFalse */\n        ]);\n\n      case \"byte\":\n        return Uint8Array.from([2\n        /* byte */\n        , header.value]);\n\n      case \"short\":\n        var shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, 3\n        /* short */\n        );\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n\n      case \"integer\":\n        var intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, 4\n        /* integer */\n        );\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n\n      case \"long\":\n        var longBytes = new Uint8Array(9);\n        longBytes[0] = 5\n        /* long */\n        ;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n\n      case \"binary\":\n        var binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, 6\n        /* byteArray */\n        );\n        binView.setUint16(1, header.value.byteLength, false);\n        var binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n\n      case \"string\":\n        var utf8Bytes = this.fromUtf8(header.value);\n        var strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, 7\n        /* string */\n        );\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        var strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n\n      case \"timestamp\":\n        var tsBytes = new Uint8Array(9);\n        tsBytes[0] = 8\n        /* timestamp */\n        ;\n        tsBytes.set(Int64_1.Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(\"Invalid UUID received: \" + header.value);\n        }\n\n        var uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = 9\n        /* uuid */\n        ;\n        uuidBytes.set(util_hex_encoding_1.fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  };\n\n  HeaderMarshaller.prototype.parse = function (headers) {\n    var out = {};\n    var position = 0;\n\n    while (position < headers.byteLength) {\n      var nameLength = headers.getUint8(position++);\n      var name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n\n      switch (headers.getUint8(position++)) {\n        case 0\n        /* boolTrue */\n        :\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true\n          };\n          break;\n\n        case 1\n        /* boolFalse */\n        :\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false\n          };\n          break;\n\n        case 2\n        /* byte */\n        :\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++)\n          };\n          break;\n\n        case 3\n        /* short */\n        :\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false)\n          };\n          position += 2;\n          break;\n\n        case 4\n        /* integer */\n        :\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false)\n          };\n          position += 4;\n          break;\n\n        case 5\n        /* long */\n        :\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))\n          };\n          position += 8;\n          break;\n\n        case 6\n        /* byteArray */\n        :\n          var binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)\n          };\n          position += binaryLength;\n          break;\n\n        case 7\n        /* string */\n        :\n          var stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))\n          };\n          position += stringLength;\n          break;\n\n        case 8\n        /* timestamp */\n        :\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())\n          };\n          position += 8;\n          break;\n\n        case 9\n        /* uuid */\n        :\n          var uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: util_hex_encoding_1.toHex(uuidBytes.subarray(0, 4)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(4, 6)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(6, 8)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(8, 10)) + \"-\" + util_hex_encoding_1.toHex(uuidBytes.subarray(10))\n          };\n          break;\n\n        default:\n          throw new Error(\"Unrecognized header type tag\");\n      }\n    }\n\n    return out;\n  };\n\n  return HeaderMarshaller;\n}();\n\nexports.HeaderMarshaller = HeaderMarshaller;\nvar HEADER_VALUE_TYPE;\n\n(function (HEADER_VALUE_TYPE) {\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolTrue\"] = 0] = \"boolTrue\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolFalse\"] = 1] = \"boolFalse\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byte\"] = 2] = \"byte\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"short\"] = 3] = \"short\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"integer\"] = 4] = \"integer\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"long\"] = 5] = \"long\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byteArray\"] = 6] = \"byteArray\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"string\"] = 7] = \"string\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"timestamp\"] = 8] = \"timestamp\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"uuid\"] = 9] = \"uuid\";\n})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));\n\nvar BOOLEAN_TAG = \"boolean\";\nvar BYTE_TAG = \"byte\";\nvar SHORT_TAG = \"short\";\nvar INT_TAG = \"integer\";\nvar LONG_TAG = \"long\";\nvar BINARY_TAG = \"binary\";\nvar STRING_TAG = \"string\";\nvar TIMESTAMP_TAG = \"timestamp\";\nvar UUID_TAG = \"uuid\";\nvar UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;","map":{"version":3,"sources":["../../src/HeaderMarshaller.ts"],"names":[],"mappings":"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","sourcesContent":["import { Decoder, Encoder, MessageHeaders, MessageHeaderValue } from \"@aws-sdk/types\";\nimport { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\n\nimport { Int64 } from \"./Int64\";\n\n/**\n * @internal\n */\nexport class HeaderMarshaller {\n  constructor(private readonly toUtf8: Encoder, private readonly fromUtf8: Decoder) {}\n\n  format(headers: MessageHeaders): Uint8Array {\n    const chunks: Array<Uint8Array> = [];\n\n    for (const headerName of Object.keys(headers)) {\n      const bytes = this.fromUtf8(headerName);\n      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n    }\n\n    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));\n    let position = 0;\n    for (const chunk of chunks) {\n      out.set(chunk, position);\n      position += chunk.byteLength;\n    }\n\n    return out;\n  }\n\n  private formatHeaderValue(header: MessageHeaderValue): Uint8Array {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? HEADER_VALUE_TYPE.boolTrue : HEADER_VALUE_TYPE.boolFalse]);\n      case \"byte\":\n        return Uint8Array.from([HEADER_VALUE_TYPE.byte, header.value]);\n      case \"short\":\n        const shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, HEADER_VALUE_TYPE.short);\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n      case \"integer\":\n        const intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, HEADER_VALUE_TYPE.integer);\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n      case \"long\":\n        const longBytes = new Uint8Array(9);\n        longBytes[0] = HEADER_VALUE_TYPE.long;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n      case \"binary\":\n        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, HEADER_VALUE_TYPE.byteArray);\n        binView.setUint16(1, header.value.byteLength, false);\n        const binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n      case \"string\":\n        const utf8Bytes = this.fromUtf8(header.value);\n        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, HEADER_VALUE_TYPE.string);\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        const strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n      case \"timestamp\":\n        const tsBytes = new Uint8Array(9);\n        tsBytes[0] = HEADER_VALUE_TYPE.timestamp;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(`Invalid UUID received: ${header.value}`);\n        }\n\n        const uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = HEADER_VALUE_TYPE.uuid;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  }\n\n  parse(headers: DataView): MessageHeaders {\n    const out: MessageHeaders = {};\n    let position = 0;\n\n    while (position < headers.byteLength) {\n      const nameLength = headers.getUint8(position++);\n      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n\n      switch (headers.getUint8(position++)) {\n        case HEADER_VALUE_TYPE.boolTrue:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true,\n          };\n          break;\n        case HEADER_VALUE_TYPE.boolFalse:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false,\n          };\n          break;\n        case HEADER_VALUE_TYPE.byte:\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++),\n          };\n          break;\n        case HEADER_VALUE_TYPE.short:\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false),\n          };\n          position += 2;\n          break;\n        case HEADER_VALUE_TYPE.integer:\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false),\n          };\n          position += 4;\n          break;\n        case HEADER_VALUE_TYPE.long:\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.byteArray:\n          const binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),\n          };\n          position += binaryLength;\n          break;\n        case HEADER_VALUE_TYPE.string:\n          const stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),\n          };\n          position += stringLength;\n          break;\n        case HEADER_VALUE_TYPE.timestamp:\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.uuid:\n          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(\n              uuidBytes.subarray(6, 8)\n            )}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,\n          };\n          break;\n        default:\n          throw new Error(`Unrecognized header type tag`);\n      }\n    }\n\n    return out;\n  }\n}\n\nconst enum HEADER_VALUE_TYPE {\n  boolTrue = 0,\n  boolFalse,\n  byte,\n  short,\n  integer,\n  long,\n  byteArray,\n  string,\n  timestamp,\n  uuid,\n}\n\nconst BOOLEAN_TAG = \"boolean\";\nconst BYTE_TAG = \"byte\";\nconst SHORT_TAG = \"short\";\nconst INT_TAG = \"integer\";\nconst LONG_TAG = \"long\";\nconst BINARY_TAG = \"binary\";\nconst STRING_TAG = \"string\";\nconst TIMESTAMP_TAG = \"timestamp\";\nconst UUID_TAG = \"uuid\";\n\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}