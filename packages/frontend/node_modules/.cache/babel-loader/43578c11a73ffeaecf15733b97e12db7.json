{"ast":null,"code":"// code obtained from https://github.com/bbc/stt-align-node\nimport { toWords } from 'number-to-words';\nimport difflib from 'difflib';\nimport everpolate from 'everpolate';\n/**\n * https://stackoverflow.com/questions/175739/built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number\n * @param {*}  num\n * @return {boolean} - if it's a number true, if it's not false.\n */\n\nfunction isANumber(num) {\n  return !isNaN(num);\n}\n\nfunction removeTrailingPunctuation(str) {\n  return str.replace(/\\.$/, '');\n}\n/**\n * removes capitalization, punctuation and converts numbers to letters\n * @param {string} wordText - word text\n * @return {string}\n * handles edge case if word is undefined, and returns undefined in that instance\n */\n\n\nfunction normaliseWord(wordText) {\n  if (wordText) {\n    const wordTextResult = wordText.toLowerCase().trim().replace(/[^a-z|0-9|.]+/g, '');\n\n    if (isANumber(wordTextResult)) {\n      const sanitizedWord = removeTrailingPunctuation(wordTextResult);\n\n      if (sanitizedWord !== '') {\n        return toWords(sanitizedWord);\n      }\n    }\n\n    return wordTextResult;\n  } else {\n    return wordText;\n  }\n} // using neighboring words to set missing start and end time when present\n\n\nfunction interpolationOptimization(wordsList) {\n  return wordsList.map((word, index) => {\n    let wordTmp = word; // setting the start time of each unmatched word to the previous word’s end time - when present\n    // does not first element in list edge case\n\n    if ('start' in word && index !== 0) {\n      const previousWord = wordsList[index - 1];\n\n      if ('end' in previousWord) {\n        wordTmp = {\n          start: previousWord.end,\n          end: word.end,\n          word: word.word\n        };\n      }\n    } // TODO: handle first item ?\n    // setting the end time of each unmatched word to the next word’s start time - when present\n    // does handle last element in list edge case\n\n\n    if ('end' in word && index !== wordsList.length - 1) {\n      const nextWord = wordsList[index + 1];\n\n      if ('start' in nextWord) {\n        wordTmp = {\n          end: nextWord.start,\n          start: word.start,\n          word: word.word\n        };\n      }\n    } // TODO: handle last item ?\n\n\n    return wordTmp;\n  });\n} // after the interpolation, some words have overlapping timecodes.\n// the end time of the previous word is greater then the start of the current word\n// altho negligible when using in a transcript editor context\n// we want to avoid this, coz it causes issues when using the time of the words to generate\n// auto segmented captions. As it results in sentence\n// boundaries overlapping on screen during playback\n\n\nfunction adjustTimecodesBoundaries(words) {\n  return words.map((word, index, arr) => {\n    // excluding first element\n    if (index !== 0) {\n      const previousWord = arr[index - 1];\n      const currentWord = word;\n\n      if (previousWord.end > currentWord.start) {\n        word.start = previousWord.end;\n      }\n\n      return word;\n    }\n\n    return word;\n  });\n}\n\nfunction interpolate(wordsList) {\n  const words = interpolationOptimization(wordsList);\n  const indicies = [...Array(words.length).keys()];\n  const indiciesWithStart = [];\n  const indiciesWithEnd = [];\n  const startTimes = [];\n  const endTimes = [];\n  words.forEach((word, index) => {\n    if ('start' in word) {\n      indiciesWithStart.push(index);\n      startTimes.push(word.start);\n    }\n\n    if ('end' in word) {\n      indiciesWithEnd.push(index);\n      endTimes.push(word.end);\n    }\n  }); // http://borischumichev.github.io/everpolate/#linear\n\n  const outStartTimes = everpolate.linear(indicies, indiciesWithStart, startTimes);\n  const outEndTimes = everpolate.linear(indicies, indiciesWithEnd, endTimes);\n  const wordsResults = words.map((word, index) => {\n    if (!('start' in word)) {\n      word.start = outStartTimes[index];\n    }\n\n    if (!('end' in word)) {\n      word.end = outEndTimes[index];\n    }\n\n    return word;\n  });\n  return adjustTimecodesBoundaries(wordsResults);\n}\n/**\n *\n * @param {array} sttWords - array of STT words\n * @param {array} transcriptWords - array of base text accurate words\n */\n\n\nfunction alignWords(sttWords, transcriptWords) {\n  // # convert words to lowercase and remove numbers and special characters\n  const sttWordsStripped = sttWords.map(word => {\n    return normaliseWord(word.word);\n  });\n  const transcriptWordsStripped = transcriptWords.map(word => {\n    return normaliseWord(word);\n  }); // # create empty list to receive data\n\n  const transcriptData = []; // empty objects as place holder\n\n  transcriptWords.forEach(() => {\n    transcriptData.push({});\n  }); // # populate transcriptData with matching words\n  // // if they are same length, just interpolate words ?\n  // http://qiao.github.io/difflib.js/\n\n  const matcher = new difflib.SequenceMatcher(null, sttWordsStripped, transcriptWordsStripped);\n  const opCodes = matcher.getOpcodes();\n  opCodes.forEach(opCode => {\n    const matchType = opCode[0];\n    const sttStartIndex = opCode[1];\n    const sttEndIndex = opCode[2];\n    const baseTextStartIndex = opCode[3];\n\n    if (matchType === 'equal') {\n      // slice does not not include the end - hence +1\n      const sttDataSegment = sttWords.slice(sttStartIndex, sttEndIndex);\n      transcriptData.splice(baseTextStartIndex, sttDataSegment.length, ...sttDataSegment);\n    }\n\n    transcriptData.forEach((wordObject, index) => {\n      wordObject.word = transcriptWords[index];\n    }); // # replace words with originals\n  }); // # fill in missing timestamps\n\n  return interpolate(transcriptData);\n}\n\nexport default alignWords;","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/packages/frontend/src/packages/components/timed-text-editor/UpdateTimestamps/stt-align-node.js"],"names":["toWords","difflib","everpolate","isANumber","num","isNaN","removeTrailingPunctuation","str","replace","normaliseWord","wordText","wordTextResult","toLowerCase","trim","sanitizedWord","interpolationOptimization","wordsList","map","word","index","wordTmp","previousWord","start","end","length","nextWord","adjustTimecodesBoundaries","words","arr","currentWord","interpolate","indicies","Array","keys","indiciesWithStart","indiciesWithEnd","startTimes","endTimes","forEach","push","outStartTimes","linear","outEndTimes","wordsResults","alignWords","sttWords","transcriptWords","sttWordsStripped","transcriptWordsStripped","transcriptData","matcher","SequenceMatcher","opCodes","getOpcodes","opCode","matchType","sttStartIndex","sttEndIndex","baseTextStartIndex","sttDataSegment","slice","splice","wordObject"],"mappings":"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","sourcesContent":["// code obtained from https://github.com/bbc/stt-align-node\n\nimport { toWords } from 'number-to-words';\nimport difflib from 'difflib';\nimport everpolate from 'everpolate';\n\n/**\n * https://stackoverflow.com/questions/175739/built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number\n * @param {*}  num\n * @return {boolean} - if it's a number true, if it's not false.\n */\nfunction isANumber(num) {\n  return !isNaN(num);\n}\n\nfunction removeTrailingPunctuation(str) {\n  return str.replace(/\\.$/, '');\n}\n\n/**\n * removes capitalization, punctuation and converts numbers to letters\n * @param {string} wordText - word text\n * @return {string}\n * handles edge case if word is undefined, and returns undefined in that instance\n */\nfunction normaliseWord(wordText) {\n  if (wordText) {\n    const wordTextResult = wordText.toLowerCase().trim().replace(/[^a-z|0-9|.]+/g, '');\n    if (isANumber(wordTextResult)) {\n      const sanitizedWord = removeTrailingPunctuation(wordTextResult);\n      if (sanitizedWord !== '') {\n        return toWords(sanitizedWord);\n      }\n    }\n\n    return wordTextResult;\n  } else {\n    return wordText;\n  }\n}\n\n// using neighboring words to set missing start and end time when present\nfunction interpolationOptimization(wordsList) {\n  return wordsList.map((word, index) => {\n    let wordTmp = word;\n    // setting the start time of each unmatched word to the previous word’s end time - when present\n    // does not first element in list edge case\n\n    if (('start' in word) && (index !== 0)) {\n      const previousWord = wordsList[index - 1];\n      if ('end' in previousWord) {\n        wordTmp = {\n          start: previousWord.end,\n          end: word.end,\n          word: word.word\n        };\n      }\n    }\n    // TODO: handle first item ?\n    // setting the end time of each unmatched word to the next word’s start time - when present\n    // does handle last element in list edge case\n    if (('end' in word) && (index !== (wordsList.length - 1))) {\n      const nextWord = wordsList[index + 1];\n      if ('start' in nextWord) {\n        wordTmp = {\n          end: nextWord.start,\n          start: word.start,\n          word: word.word\n        };\n      }\n    }\n\n    // TODO: handle last item ?\n    return wordTmp;\n  });\n}\n\n// after the interpolation, some words have overlapping timecodes.\n// the end time of the previous word is greater then the start of the current word\n// altho negligible when using in a transcript editor context\n// we want to avoid this, coz it causes issues when using the time of the words to generate\n// auto segmented captions. As it results in sentence\n// boundaries overlapping on screen during playback\nfunction adjustTimecodesBoundaries(words) {\n\n  return words.map((word, index, arr) => {\n    // excluding first element\n    if (index !== 0 ) {\n  \n      const previousWord = arr[index - 1];\n      const currentWord = word;\n      if (previousWord.end > currentWord.start) {\n        word.start = previousWord.end;\n      }\n\n      return word;\n    }\n\n    return word;\n  });\n}\n\nfunction interpolate(wordsList) {\n  const words = interpolationOptimization(wordsList);\n  const indicies = [ ...Array(words.length).keys() ];\n  const indiciesWithStart = [];\n  const indiciesWithEnd = [];\n  const startTimes = [];\n  const endTimes = [];\n\n  words.forEach((word, index) => {\n    if ('start' in word) {\n      indiciesWithStart.push(index);\n      startTimes.push(word.start);\n    }\n\n    if ('end' in word) {\n      indiciesWithEnd.push(index);\n      endTimes.push(word.end);\n    }\n  });\n  // http://borischumichev.github.io/everpolate/#linear\n  const outStartTimes = everpolate.linear(indicies, indiciesWithStart, startTimes);\n  const outEndTimes = everpolate.linear(indicies, indiciesWithEnd, endTimes);\n  const wordsResults = words.map((word, index) => {\n    if (!('start' in word)) {\n      word.start = outStartTimes[index];\n    }\n    if (!('end' in word)) {\n      word.end = outEndTimes[index];\n    }\n\n    return word;\n  });\n\n  return adjustTimecodesBoundaries(wordsResults);\n}\n\n/**\n *\n * @param {array} sttWords - array of STT words\n * @param {array} transcriptWords - array of base text accurate words\n */\nfunction alignWords(sttWords, transcriptWords) {\n  // # convert words to lowercase and remove numbers and special characters\n  const sttWordsStripped = sttWords.map((word) => {\n    return normaliseWord(word.word);\n  });\n\n  const transcriptWordsStripped = transcriptWords.map((word) => {\n    return normaliseWord(word);\n  });\n  // # create empty list to receive data\n  const transcriptData = [];\n  // empty objects as place holder\n  transcriptWords.forEach(() => {\n    transcriptData.push({});\n  });\n  // # populate transcriptData with matching words\n  // // if they are same length, just interpolate words ?\n  // http://qiao.github.io/difflib.js/\n  const matcher = new difflib.SequenceMatcher(null, sttWordsStripped, transcriptWordsStripped);\n  const opCodes = matcher.getOpcodes();\n\n  opCodes.forEach((opCode) => {\n    const matchType = opCode[0];\n    const sttStartIndex = opCode[1];\n    const sttEndIndex = opCode[2];\n    const baseTextStartIndex = opCode[3];\n\n    if (matchType === 'equal' ) {\n      // slice does not not include the end - hence +1\n      const sttDataSegment = sttWords.slice(sttStartIndex, sttEndIndex);\n      transcriptData.splice(baseTextStartIndex, sttDataSegment.length, ...sttDataSegment);\n    }\n\n    transcriptData.forEach((wordObject, index) => {\n      wordObject.word = transcriptWords[index];\n    });\n    // # replace words with originals\n  });\n\n  // # fill in missing timestamps\n  return interpolate(transcriptData);\n}\n\nexport default alignWords;\n"]},"metadata":{},"sourceType":"module"}