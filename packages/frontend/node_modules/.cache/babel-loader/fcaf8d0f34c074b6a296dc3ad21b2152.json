{"ast":null,"code":"import { __values } from \"tslib\";\nimport { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from \"./constants\";\n/**\n * @internal\n */\n\nexport function getCanonicalHeaders(_a, unsignableHeaders, signableHeaders) {\n  var e_1, _b;\n\n  var headers = _a.headers;\n  var canonical = {};\n\n  try {\n    for (var _c = __values(Object.keys(headers).sort()), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var headerName = _d.value;\n      var canonicalHeaderName = headerName.toLowerCase();\n\n      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {\n        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {\n          continue;\n        }\n      }\n\n      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, \" \");\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return canonical;\n}","map":{"version":3,"sources":["../../src/getCanonicalHeaders.ts"],"names":[],"mappings":";AAEA,SAAS,yBAAT,EAAoC,oBAApC,EAA0D,kBAA1D,QAAoF,aAApF;AAEA;;;;AAGA,OAAM,SAAU,mBAAV,CACJ,EADI,EAEJ,iBAFI,EAGJ,eAHI,EAGyB;;;MAF3B,OAAO,GAAA,EAAA,CAAA,O;AAIT,MAAM,SAAS,GAAc,EAA7B;;;AACA,SAAyB,IAAA,EAAA,GAAA,QAAA,CAAA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,IAArB,EAAA,CAAA,EAA2B,EAAA,GAAA,EAAA,CAAA,IAAA,EAApD,EAAoD,CAAA,EAAA,CAAA,IAApD,EAAoD,EAAA,GAAA,EAAA,CAAA,IAAA,EAApD,EAAsD;AAAjD,UAAM,UAAU,GAAA,EAAA,CAAA,KAAhB;AACH,UAAM,mBAAmB,GAAG,UAAU,CAAC,WAAX,EAA5B;;AACA,UACE,mBAAmB,IAAI,yBAAvB,KACA,iBAAiB,KAAA,IAAjB,IAAA,iBAAiB,KAAA,KAAA,CAAjB,GAAiB,KAAA,CAAjB,GAAA,iBAAiB,CAAE,GAAnB,CAAuB,mBAAvB,CADA,KAEA,oBAAoB,CAAC,IAArB,CAA0B,mBAA1B,CAFA,IAGA,kBAAkB,CAAC,IAAnB,CAAwB,mBAAxB,CAJF,EAKE;AACA,YAAI,CAAC,eAAD,IAAqB,eAAe,IAAI,CAAC,eAAe,CAAC,GAAhB,CAAoB,mBAApB,CAA7C,EAAwF;AACtF;AACD;AACF;;AAED,MAAA,SAAS,CAAC,mBAAD,CAAT,GAAiC,OAAO,CAAC,UAAD,CAAP,CAAoB,IAApB,GAA2B,OAA3B,CAAmC,MAAnC,EAA2C,GAA3C,CAAjC;AACD;;;;;;;;;;;;;AAED,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["import { __values } from \"tslib\";\nimport { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from \"./constants\";\n/**\n * @internal\n */\nexport function getCanonicalHeaders(_a, unsignableHeaders, signableHeaders) {\n    var e_1, _b;\n    var headers = _a.headers;\n    var canonical = {};\n    try {\n        for (var _c = __values(Object.keys(headers).sort()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var headerName = _d.value;\n            var canonicalHeaderName = headerName.toLowerCase();\n            if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||\n                PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||\n                SEC_HEADER_PATTERN.test(canonicalHeaderName)) {\n                if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {\n                    continue;\n                }\n            }\n            canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, \" \");\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return canonical;\n}\n//# sourceMappingURL=getCanonicalHeaders.js.map"]},"metadata":{},"sourceType":"module"}