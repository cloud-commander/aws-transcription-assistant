{"ast":null,"code":"import removeSpaceAfterCarriageReturn from'../util/remove-space-after-carriage-return.js';/*\n  * Helper function\n  * folds array of words\n  * adds `\\n`\n  * foldNumber = char after which to fold. eg 35 char default\n  * TODO: this could be refactored with smaller helper functions\n  */function foldWordsReturnArray(textArray){var foldNumber=arguments.length>1&&arguments[1]!==undefined?arguments[1]:35;var counter=0;var result=textArray.map(function(word,index,list){counter+=word.length+1;//resetting counter when there is a 'paragraph' line break \\n\\n\nif(counter<=foldNumber){// if not last word in list\n// cover edge case last element in array does not have a next element\nif(list[index+1]!==undefined){var nextElementLength=list[index+1].length;//check if adding next word would make the line go over the char limit foldNumber\nif(counter+nextElementLength<foldNumber){return word;}else{// if it makes it go over, reset counter, return and add line break\ncounter=0;return\"\".concat(word,\"\\n\");}//last word in the list\n}else{return word;}// if not greater then char foldNumber\n}else{counter=0;return\"\".concat(word,\"\\n\");}});return result;}/*\n* text string of words\n* foldNumber = char after which to fold. eg 35 char.\n*/function foldWords(text,foldNumber){// split on two line break\nvar lineArr=text.split('\\n\\n');// fold each line on non fold number char count\nvar foldedWordsInArray=lineArr.map(function(line){return foldWordsReturnArray(line.split(' '),foldNumber);});// flatten result\nvar foldedWordsFlatten=foldedWordsInArray.map(function(line){return line.join(' ');});// remove space after carriage return \\n in lines\nvar result=foldedWordsFlatten.map(function(r){return removeSpaceAfterCarriageReturn(r);});// return text\nreturn result.join('\\n\\n');}export default foldWords;","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/packages/frontend/src/packages/export-adapters/subtitles-generator/presegment-text/fold/index.js"],"names":["removeSpaceAfterCarriageReturn","foldWordsReturnArray","textArray","foldNumber","counter","result","map","word","index","list","length","undefined","nextElementLength","foldWords","text","lineArr","split","foldedWordsInArray","line","foldedWordsFlatten","join","r"],"mappings":"AACA,MAAOA,CAAAA,8BAAP,KAA2C,+CAA3C,CAEA;;;;;;IAOA,QAASC,CAAAA,oBAAT,CAA8BC,SAA9B,CAA0D,IAAjBC,CAAAA,UAAiB,2DAAJ,EAAI,CACxD,GAAIC,CAAAA,OAAO,CAAG,CAAd,CACA,GAAIC,CAAAA,MAAM,CAAGH,SAAS,CAACI,GAAV,CAAc,SAACC,IAAD,CAAOC,KAAP,CAAcC,IAAd,CAAuB,CAChDL,OAAO,EAAIG,IAAI,CAACG,MAAL,CAAc,CAAzB,CACA;AACA,GAAIN,OAAO,EAAID,UAAf,CAA2B,CAC3B;AACA;AACE,GAAIM,IAAI,CAACD,KAAK,CAAG,CAAT,CAAJ,GAAoBG,SAAxB,CAAmC,CACjC,GAAIC,CAAAA,iBAAiB,CAAGH,IAAI,CAACD,KAAK,CAAG,CAAT,CAAJ,CAAgBE,MAAxC,CACA;AACA,GAAKN,OAAO,CAAGQ,iBAAX,CAAgCT,UAApC,CAAgD,CAC9C,MAAOI,CAAAA,IAAP,CACD,CAFD,IAEO,CACL;AACAH,OAAO,CAAG,CAAV,CAEA,gBAAWG,IAAX,OACD,CACD;AACD,CAZD,IAYO,CACL,MAAOA,CAAAA,IAAP,CACD,CACD;AACD,CAnBD,IAmBO,CACLH,OAAO,CAAG,CAAV,CAEA,gBAAWG,IAAX,OACD,CACF,CA3BY,CAAb,CA6BA,MAAOF,CAAAA,MAAP,CACD,CAED;;;EAIA,QAASQ,CAAAA,SAAT,CAAmBC,IAAnB,CAAyBX,UAAzB,CAAqC,CACnC;AACA,GAAIY,CAAAA,OAAO,CAAGD,IAAI,CAACE,KAAL,CAAW,MAAX,CAAd,CACA;AACA,GAAIC,CAAAA,kBAAkB,CAAGF,OAAO,CAACT,GAAR,CAAY,SAACY,IAAD,CAAU,CAC9C,MAAOjB,CAAAA,oBAAoB,CAACiB,IAAI,CAACF,KAAL,CAAW,GAAX,CAAD,CAAkBb,UAAlB,CAA3B,CACA,CAFwB,CAAzB,CAGA;AACA,GAAIgB,CAAAA,kBAAkB,CAAGF,kBAAkB,CAACX,GAAnB,CAAuB,SAACY,IAAD,CAAU,CACxD,MAAOA,CAAAA,IAAI,CAACE,IAAL,CAAU,GAAV,CAAP,CACD,CAFwB,CAAzB,CAIA;AACA,GAAMf,CAAAA,MAAM,CAAGc,kBAAkB,CAACb,GAAnB,CAAuB,SAACe,CAAD,CAAO,CAAE,MAAOrB,CAAAA,8BAA8B,CAACqB,CAAD,CAArC,CAA2C,CAA3E,CAAf,CACA;AAEA,MAAOhB,CAAAA,MAAM,CAACe,IAAP,CAAY,MAAZ,CAAP,CACD,CAED,cAAeP,CAAAA,SAAf","sourcesContent":["\nimport removeSpaceAfterCarriageReturn from '../util/remove-space-after-carriage-return.js';\n\n/*\n  * Helper function\n  * folds array of words\n  * adds `\\n`\n  * foldNumber = char after which to fold. eg 35 char default\n  * TODO: this could be refactored with smaller helper functions\n  */\nfunction foldWordsReturnArray(textArray, foldNumber = 35) {\n  var counter = 0;\n  var result = textArray.map((word, index, list) => {\n    counter += word.length + 1;\n    //resetting counter when there is a 'paragraph' line break \\n\\n\n    if (counter <= foldNumber) {\n    // if not last word in list\n    // cover edge case last element in array does not have a next element\n      if (list[index + 1] !== undefined) {\n        var nextElementLength = list[index + 1].length;\n        //check if adding next word would make the line go over the char limit foldNumber\n        if ((counter + nextElementLength) < foldNumber) {\n          return word;\n        } else {\n          // if it makes it go over, reset counter, return and add line break\n          counter = 0;\n\n          return `${ word }\\n`;\n        }\n        //last word in the list\n      } else {\n        return word;\n      }\n      // if not greater then char foldNumber\n    } else {\n      counter = 0;\n\n      return `${ word }\\n`;\n    }\n  });\n\n  return result;\n}\n\n/*\n* text string of words\n* foldNumber = char after which to fold. eg 35 char.\n*/\nfunction foldWords(text, foldNumber) {\n  // split on two line break\n  var lineArr = text.split('\\n\\n');\n  // fold each line on non fold number char count\n  var foldedWordsInArray = lineArr.map((line) => {\n  \treturn foldWordsReturnArray(line.split(' '), foldNumber);\n  });\n  // flatten result\n  var foldedWordsFlatten = foldedWordsInArray.map((line) => {\n    return line.join(' ');\n  });\n\n  // remove space after carriage return \\n in lines\n  const result = foldedWordsFlatten.map((r) => { return removeSpaceAfterCarriageReturn(r); });\n  // return text\n\n  return result.join('\\n\\n');\n}\n\nexport default foldWords;\n"]},"metadata":{},"sourceType":"module"}