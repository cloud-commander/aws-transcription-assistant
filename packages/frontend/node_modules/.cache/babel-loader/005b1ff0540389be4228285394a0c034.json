{"ast":null,"code":"/**\n *  Convert Speechmatics Json to DraftJs\n *  see `sample` folder for example of input and output as well as `example-usage.js`\n */\nimport generateEntitiesRanges from '../generate-entities-ranges/index.js';\n/**\n * Determines the speaker of a paragraph by comparing the start time of the paragraph with\n * the speaker times.\n * @param {float} start - Starting point of paragraph\n * @param {array} speakers - list of all speakers with start and end time\n */\n\nconst getSpeaker = (start, speakers) => {\n  for (var speakerIdx in speakers) {\n    const speaker = speakers[speakerIdx];\n    const segmentStart = parseFloat(start);\n\n    if (segmentStart >= speaker.start & segmentStart < speaker.end) {\n      return speaker.name;\n    }\n  }\n\n  return 'UNK';\n};\n/**\n * groups words list from speechmatics based on speaker change and paragraph length.\n * @param {array} words - array of words objects from speechmatics transcript\n * @param {array} speakers - array of speaker objects from speechmatics transcript\n * @param {int} words - number of words which trigger a paragraph break\n */\n\n\nconst groupWordsInParagraphs = (words, speakers, maxParagraphWords) => {\n  const results = [];\n  let paragraph = {\n    words: [],\n    text: [],\n    speaker: ''\n  };\n  let oldSpeaker = getSpeaker(words[0].start, speakers);\n  let newSpeaker;\n  let sentenceEnd = false;\n  words.forEach(word => {\n    newSpeaker = getSpeaker(word.start, speakers); // if speaker changes\n\n    if (newSpeaker !== oldSpeaker || paragraph.words.length > maxParagraphWords && sentenceEnd) {\n      paragraph.speaker = oldSpeaker;\n      results.push(paragraph);\n      oldSpeaker = newSpeaker; // reset paragraph\n\n      paragraph = {\n        words: [],\n        text: []\n      };\n    }\n\n    paragraph.words.push(word);\n    paragraph.text.push(word.punct);\n    sentenceEnd = /[.?!]/.test(word.punct) ? true : false;\n  });\n  paragraph.speaker = oldSpeaker;\n  results.push(paragraph);\n  return results;\n};\n/**\n * Speechmatics treats punctuation as own words. This function merges punctuations with\n * the pevious word and adjusts the total duration of the word.\n * @param {array} words - array of words objects from speechmatics transcript\n */\n\n\nconst curatePunctuation = words => {\n  const curatedWords = [];\n  words.forEach(word => {\n    if (/[.?!]/.test(word.name)) {\n      curatedWords[curatedWords.length - 1].name = curatedWords[curatedWords.length - 1].name + word.name;\n      curatedWords[curatedWords.length - 1].duration = (parseFloat(curatedWords[curatedWords.length - 1].duration) + parseFloat(word.duration)).toString();\n    } else {\n      curatedWords.push(word);\n    }\n  });\n  return curatedWords;\n};\n\nconst speechmaticsToDraft = speechmaticsJson => {\n  const results = [];\n  let tmpWords;\n  tmpWords = curatePunctuation(speechmaticsJson.words);\n  tmpWords = tmpWords.map((element, index) => {\n    return {\n      start: element.time,\n      end: (parseFloat(element.time) + parseFloat(element.duration)).toString(),\n      confidence: element.confidence,\n      word: element.name.toLowerCase().replace(/[.?!]/g, ''),\n      punct: element.name,\n      index: index\n    };\n  });\n  let tmpSpeakers;\n  tmpSpeakers = speechmaticsJson.speakers;\n  tmpSpeakers = tmpSpeakers.map(element => {\n    return {\n      start: parseFloat(element.time),\n      end: parseFloat(element.time) + parseFloat(element.duration),\n      name: element.name\n    };\n  });\n  const wordsByParagraphs = groupWordsInParagraphs(tmpWords, tmpSpeakers, 150);\n  wordsByParagraphs.forEach(paragraph => {\n    const paragraphStart = paragraph.words[0].start;\n    const draftJsContentBlockParagraph = {\n      text: paragraph.text.join(' '),\n      type: 'paragraph',\n      data: {\n        speaker: paragraph.speaker,\n        words: paragraph.words,\n        start: paragraphStart\n      },\n      // the entities as ranges are each word in the space-joined text,\n      // so it needs to be compute for each the offset from the beginning of the paragraph and the length\n      entityRanges: generateEntitiesRanges(paragraph.words, 'punct') // wordAttributeName\n\n    };\n    results.push(draftJsContentBlockParagraph);\n  });\n  return results;\n};\n\nexport default speechmaticsToDraft;","map":{"version":3,"sources":["/home/cmsgdiav/Desktop/React Projects/aws-transcription-assistant-05/packages/frontend/src/packages/stt-adapters/speechmatics/index.js"],"names":["generateEntitiesRanges","getSpeaker","start","speakers","speakerIdx","speaker","segmentStart","parseFloat","end","name","groupWordsInParagraphs","words","maxParagraphWords","results","paragraph","text","oldSpeaker","newSpeaker","sentenceEnd","forEach","word","length","push","punct","test","curatePunctuation","curatedWords","duration","toString","speechmaticsToDraft","speechmaticsJson","tmpWords","map","element","index","time","confidence","toLowerCase","replace","tmpSpeakers","wordsByParagraphs","paragraphStart","draftJsContentBlockParagraph","join","type","data","entityRanges"],"mappings":"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","sourcesContent":["/**\n *  Convert Speechmatics Json to DraftJs\n *  see `sample` folder for example of input and output as well as `example-usage.js`\n */\n\nimport generateEntitiesRanges from '../generate-entities-ranges/index.js';\n\n/**\n * Determines the speaker of a paragraph by comparing the start time of the paragraph with\n * the speaker times.\n * @param {float} start - Starting point of paragraph\n * @param {array} speakers - list of all speakers with start and end time\n */\nconst getSpeaker = (start, speakers) => {\n  for (var speakerIdx in speakers) {\n    const speaker = speakers[speakerIdx];\n    const segmentStart = parseFloat(start);\n    if (segmentStart >= speaker.start & segmentStart < speaker.end) {\n      return speaker.name;\n    }\n  }\n\n  return 'UNK';\n};\n\n/**\n * groups words list from speechmatics based on speaker change and paragraph length.\n * @param {array} words - array of words objects from speechmatics transcript\n * @param {array} speakers - array of speaker objects from speechmatics transcript\n * @param {int} words - number of words which trigger a paragraph break\n */\nconst groupWordsInParagraphs = (words, speakers, maxParagraphWords) => {\n  const results = [];\n  let paragraph = { words: [], text: [], speaker: '' };\n  let oldSpeaker = getSpeaker(words[0].start, speakers);\n  let newSpeaker;\n  let sentenceEnd = false;\n\n  words.forEach((word) => {\n    newSpeaker = getSpeaker(word.start, speakers);\n    // if speaker changes\n    if (newSpeaker !== oldSpeaker || (paragraph.words.length > maxParagraphWords && sentenceEnd)) {\n      paragraph.speaker = oldSpeaker;\n      results.push(paragraph);\n      oldSpeaker = newSpeaker;\n      // reset paragraph\n      paragraph = { words: [], text: [] };\n    }\n    paragraph.words.push(word);\n    paragraph.text.push(word.punct);\n    sentenceEnd = /[.?!]/.test(word.punct) ? true : false;\n  });\n\n  paragraph.speaker = oldSpeaker;\n  results.push(paragraph);\n\n  return results;\n};\n\n/**\n * Speechmatics treats punctuation as own words. This function merges punctuations with\n * the pevious word and adjusts the total duration of the word.\n * @param {array} words - array of words objects from speechmatics transcript\n */\nconst curatePunctuation = (words) => {\n  const curatedWords = [];\n  words.forEach((word) => {\n    if (/[.?!]/.test(word.name)) {\n      curatedWords[curatedWords.length - 1].name = curatedWords[curatedWords.length - 1].name + word.name;\n      curatedWords[curatedWords.length - 1].duration = (parseFloat(curatedWords[curatedWords.length - 1].duration) + parseFloat(word.duration)).toString();\n    } else {\n      curatedWords.push(word);\n    }\n  }\n  );\n\n  return curatedWords;\n};\n\nconst speechmaticsToDraft = (speechmaticsJson) => {\n  const results = [];\n\n  let tmpWords;\n  tmpWords = curatePunctuation(speechmaticsJson.words);\n  tmpWords = tmpWords.map((element, index) => {\n    return ({\n      start: element.time,\n      end: (parseFloat(element.time) + parseFloat(element.duration)).toString(),\n      confidence: element.confidence,\n      word: element.name.toLowerCase().replace(/[.?!]/g, ''),\n      punct: element.name,\n      index: index,\n    });\n  });\n\n  let tmpSpeakers;\n  tmpSpeakers = speechmaticsJson.speakers;\n  tmpSpeakers = tmpSpeakers.map((element) => {\n    return ({\n      start: parseFloat(element.time),\n      end: (parseFloat(element.time) + parseFloat(element.duration)),\n      name: element.name,\n    });\n  });\n\n  const wordsByParagraphs = groupWordsInParagraphs(tmpWords, tmpSpeakers, 150);\n\n  wordsByParagraphs.forEach((paragraph) => {\n    const paragraphStart = paragraph.words[0].start;\n    const draftJsContentBlockParagraph = {\n      text: paragraph.text.join(' '),\n      type: 'paragraph',\n      data: {\n        speaker: paragraph.speaker,\n        words: paragraph.words,\n        start: paragraphStart\n      },\n      // the entities as ranges are each word in the space-joined text,\n      // so it needs to be compute for each the offset from the beginning of the paragraph and the length\n      entityRanges: generateEntitiesRanges(paragraph.words, 'punct'), // wordAttributeName\n    };\n    results.push(draftJsContentBlockParagraph);\n  });\n\n  return results;\n};\n\nexport default speechmaticsToDraft;\n"]},"metadata":{},"sourceType":"module"}