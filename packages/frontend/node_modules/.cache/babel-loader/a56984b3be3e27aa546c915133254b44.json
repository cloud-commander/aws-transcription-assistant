{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"./constants\");\n/**\n * @internal\n */\n\n\nvar RawSha256 =\n/** @class */\nfunction () {\n  function RawSha256() {\n    this.state = Int32Array.from(constants_1.INIT);\n    this.temp = new Int32Array(64);\n    this.buffer = new Uint8Array(64);\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    /**\n     * @internal\n     */\n\n    this.finished = false;\n  }\n\n  RawSha256.prototype.update = function (data) {\n    if (this.finished) {\n      throw new Error(\"Attempted to update an already finished hash.\");\n    }\n\n    var position = 0;\n    var byteLength = data.byteLength;\n    this.bytesHashed += byteLength;\n\n    if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {\n      throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    while (byteLength > 0) {\n      this.buffer[this.bufferLength++] = data[position++];\n      byteLength--;\n\n      if (this.bufferLength === constants_1.BLOCK_SIZE) {\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n    }\n  };\n\n  RawSha256.prototype.digest = function () {\n    if (!this.finished) {\n      var bitsHashed = this.bytesHashed * 8;\n      var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n      var undecoratedLength = this.bufferLength;\n      bufferView.setUint8(this.bufferLength++, 0x80); // Ensure the final block has enough room for the hashed length\n\n      if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {\n        for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {\n          bufferView.setUint8(i, 0);\n        }\n\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n\n      for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {\n        bufferView.setUint8(i, 0);\n      }\n\n      bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);\n      bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);\n      this.hashBuffer();\n      this.finished = true;\n    } // The value in state is little-endian rather than big-endian, so flip\n    // each word into a new Uint8Array\n\n\n    var out = new Uint8Array(constants_1.DIGEST_LENGTH);\n\n    for (var i = 0; i < 8; i++) {\n      out[i * 4] = this.state[i] >>> 24 & 0xff;\n      out[i * 4 + 1] = this.state[i] >>> 16 & 0xff;\n      out[i * 4 + 2] = this.state[i] >>> 8 & 0xff;\n      out[i * 4 + 3] = this.state[i] >>> 0 & 0xff;\n    }\n\n    return out;\n  };\n\n  RawSha256.prototype.hashBuffer = function () {\n    var _a = this,\n        buffer = _a.buffer,\n        state = _a.state;\n\n    var state0 = state[0],\n        state1 = state[1],\n        state2 = state[2],\n        state3 = state[3],\n        state4 = state[4],\n        state5 = state[5],\n        state6 = state[6],\n        state7 = state[7];\n\n    for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n      if (i < 16) {\n        this.temp[i] = (buffer[i * 4] & 0xff) << 24 | (buffer[i * 4 + 1] & 0xff) << 16 | (buffer[i * 4 + 2] & 0xff) << 8 | buffer[i * 4 + 3] & 0xff;\n      } else {\n        var u = this.temp[i - 2];\n        var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;\n        u = this.temp[i - 15];\n        var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;\n        this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);\n      }\n\n      var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;\n      var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;\n      state7 = state6;\n      state6 = state5;\n      state5 = state4;\n      state4 = state3 + t1 | 0;\n      state3 = state2;\n      state2 = state1;\n      state1 = state0;\n      state0 = t1 + t2 | 0;\n    }\n\n    state[0] += state0;\n    state[1] += state1;\n    state[2] += state2;\n    state[3] += state3;\n    state[4] += state4;\n    state[5] += state5;\n    state[6] += state6;\n    state[7] += state7;\n  };\n\n  return RawSha256;\n}();\n\nexports.RawSha256 = RawSha256;","map":{"version":3,"sources":["../src/RawSha256.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"./constants\");\n/**\n * @internal\n */\nvar RawSha256 = /** @class */ (function () {\n    function RawSha256() {\n        this.state = Int32Array.from(constants_1.INIT);\n        this.temp = new Int32Array(64);\n        this.buffer = new Uint8Array(64);\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        /**\n         * @internal\n         */\n        this.finished = false;\n    }\n    RawSha256.prototype.update = function (data) {\n        if (this.finished) {\n            throw new Error(\"Attempted to update an already finished hash.\");\n        }\n        var position = 0;\n        var byteLength = data.byteLength;\n        this.bytesHashed += byteLength;\n        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {\n            throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n        }\n        while (byteLength > 0) {\n            this.buffer[this.bufferLength++] = data[position++];\n            byteLength--;\n            if (this.bufferLength === constants_1.BLOCK_SIZE) {\n                this.hashBuffer();\n                this.bufferLength = 0;\n            }\n        }\n    };\n    RawSha256.prototype.digest = function () {\n        if (!this.finished) {\n            var bitsHashed = this.bytesHashed * 8;\n            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n            var undecoratedLength = this.bufferLength;\n            bufferView.setUint8(this.bufferLength++, 0x80);\n            // Ensure the final block has enough room for the hashed length\n            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {\n                for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {\n                    bufferView.setUint8(i, 0);\n                }\n                this.hashBuffer();\n                this.bufferLength = 0;\n            }\n            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {\n                bufferView.setUint8(i, 0);\n            }\n            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);\n            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);\n            this.hashBuffer();\n            this.finished = true;\n        }\n        // The value in state is little-endian rather than big-endian, so flip\n        // each word into a new Uint8Array\n        var out = new Uint8Array(constants_1.DIGEST_LENGTH);\n        for (var i = 0; i < 8; i++) {\n            out[i * 4] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return out;\n    };\n    RawSha256.prototype.hashBuffer = function () {\n        var _a = this, buffer = _a.buffer, state = _a.state;\n        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];\n        for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n            if (i < 16) {\n                this.temp[i] =\n                    ((buffer[i * 4] & 0xff) << 24) |\n                        ((buffer[i * 4 + 1] & 0xff) << 16) |\n                        ((buffer[i * 4 + 2] & 0xff) << 8) |\n                        (buffer[i * 4 + 3] & 0xff);\n            }\n            else {\n                var u = this.temp[i - 2];\n                var t1_1 = ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);\n                u = this.temp[i - 15];\n                var t2_1 = ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);\n                this.temp[i] =\n                    ((t1_1 + this.temp[i - 7]) | 0) + ((t2_1 + this.temp[i - 16]) | 0);\n            }\n            var t1 = ((((((state4 >>> 6) | (state4 << 26)) ^\n                ((state4 >>> 11) | (state4 << 21)) ^\n                ((state4 >>> 25) | (state4 << 7))) +\n                ((state4 & state5) ^ (~state4 & state6))) |\n                0) +\n                ((state7 + ((constants_1.KEY[i] + this.temp[i]) | 0)) | 0)) |\n                0;\n            var t2 = ((((state0 >>> 2) | (state0 << 30)) ^\n                ((state0 >>> 13) | (state0 << 19)) ^\n                ((state0 >>> 22) | (state0 << 10))) +\n                ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |\n                0;\n            state7 = state6;\n            state6 = state5;\n            state5 = state4;\n            state4 = (state3 + t1) | 0;\n            state3 = state2;\n            state2 = state1;\n            state1 = state0;\n            state0 = (t1 + t2) | 0;\n        }\n        state[0] += state0;\n        state[1] += state1;\n        state[2] += state2;\n        state[3] += state3;\n        state[4] += state4;\n        state[5] += state5;\n        state[6] += state6;\n        state[7] += state7;\n    };\n    return RawSha256;\n}());\nexports.RawSha256 = RawSha256;\n//# sourceMappingURL=RawSha256.js.map"]},"metadata":{},"sourceType":"script"}